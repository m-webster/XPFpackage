import numpy as np
from common import *
from NSpace import *
from XPAlgebra import *
import itertools

## XP group generated by set of XP operators S of precision N
def XPSpan(S,N):
    S = ZMat2D(S)
    ## G is the group generated
    G = []
    ## U - set to avoid duplications in G
    U = set()
    ## raise non-diagonals to either 0 or 1 power
    ## raise diagonals to [0..d-1]    
    maxPowers = [range(XPDegree(A,N)) if XPisDiag(A) else range(2) for A in S]
    for t in itertools.product(*maxPowers):
        g = None
        for i in range(len(maxPowers)):
            h = XPPower(S[i],N,t[i])
            g = h if g is None else XPMul(g,h,N)
        t = tuple(g)
        if t not in U:
            G.append(g)
            U.add(t)
    return ZMat2D(G)

## split XP operators into non-diagonal and diagonal operators
def splitDiag(G):
    S = [[],[]]
    n = XPn(G)
    for g in G:
        i = 1 if XPisDiag(g) else 0
        S[i].append(g)
    if len(S[1]) == 0:
        S[1].append(XPI(n))
    return [ZMat(S[i],2*n+1) for i in range(2)]

## Simplify X components of XP operators G of precision N
def simplifyX(G,N):
    ## split into diagonal and non-diagonal operators
    SX,SZ = splitDiag(G)
    ## make RREF of X-components
    A = XPx(SX)
    nsp = NSpace(A,2)
    ## U is the transformation matrix
    U = nsp.getVal('P')
    ## corresponding group operations on SX
    SX = doOperations(SX,U,N)
    SX = RemoveZeroRows(SX)
    ## return both updated SX and SZ
    return np.vstack([SX,SZ])

## simplify Z components of SZ
def simplifyZ(SZ,N):
    SZ = RemoveZeroRows(SZ)
    ## A is 2*z|p
    A = XP2Zp(SZ,N)
    ## get Howell basis
    nsp = NSpace(A,2 * N)
    H = nsp.getVal('H')
    H = RemoveZeroRows(H)
    ## convert back to operators
    SZ = Zp2XP(H,N)
    return SZ

## Simplify Z component of SX
def simplifyXZ(SX,SZ,N):
    n = max(np.shape(SX)[-1],np.shape(SZ)[-1])
    SX = ZMat([ZResidual(SZ,A,N)[0] for A in SX],n)
    return SX

## vectorized version of Div
vDiv = np.vectorize(Div)
    
## return z and p components in single matrix
## if double then return 2z|p
## otherwise return z|Div(p,2,N)
def XP2Zp(A,N,double=True):
    p = np.transpose([XPp(A)])
    z = XPz(A)
    if double:
        ## in this case, we double z component
        z = 2*z
    else:
        ## in this case, we halve p component
        if np.mod(N,2) == 0:
            ## easy if N is a multiple of 2
            p = p//2
        else:
            ## otherwise, use ring Div function
            p = vDiv(p,2,N)
    return np.hstack([z,p])

## return z and p components in single matrix
## if double then return 2z|p
## otherwise return z|Div(p,2,N)
def Zp2XP(A,N,double=True):
    n = np.shape(A)[-1]
    ## p is the last column
    p = np.take(A, n-1, -1)
    ## z is the rest of the matrix
    z = np.take(A, range(n-1), -1)
    ## X component - all zero, same shape as z
    x = ZMatZeros(np.shape(z))
    if double:
        ## we need to halve z
        if np.mod(N,2) == 0:
            z = z//2
        else:
            z = vDiv(z,2,N)
    else:
        ## we need to double p
        p = np.mod(p*2,2*N)
    return makeXP(p,x,z)

## Operator Residue of A wrt diagonal canonical generators SZ
def ZResidual(SZ,A,N):
    if np.size(SZ) == 0:
        return A,ZMat([])
    x = XPx(A)
    ## H is 2*z|p
    H = XP2Zp(SZ,N)
    zp = XP2Zp(A,N)
    ## residue of xp wrt H
    zp,u = matResidual(H,zp,2*N)
    ## convert back into XP operator
    A = Zp2XP(zp,N)
    ## get new p and z components
    p,x0,z = XPcomponents(A)
    return makeXP(p,x,z),u

## Operator Residue of A wrt non-diagonal canonical generators SX
def XResidual(SX,A,N):
    if np.size(SX) == 0:
        return A,ZMat([])
    p,x,z = XPcomponents(A)
    ## H is X-component of SX
    H = XPx(SX)
    ## residue of z wrt H
    x1,u = matResidual(H,x,2)
    B = GeneratorProduct(SX,u,N)
    ## update A
    A = XPMul(A,XPInverse(B,N),N)
    return A,u

## Operator Residue of A wrt canonical generators S
def XPResidual(S,A,N): 
    SX,SZ = splitDiag(S)  
    A,a = XResidual(SX,A,N)
    # report(func_name(),XP2Str(A,N))
    B,b = ZResidual(SZ,A,N)
    # report(func_name(),XP2Str(B,N))
    return B,np.hstack([a,b])   

## perform operations represented by U on S
def doOperations(S,U,N):
    if len(S) == 0:
        return S
    temp = []
    m,n = getmn(U)
    n = XPn(S)
    for j in range(len(S),m):
        S.append(XPI(n))
    for j in range(len(U)):
        myrow = mat2list(U[j])
        op = GeneratorProduct(S,myrow,N)
        temp.append(op)
    return temp

## Prod(S[i]^u[i]) where S is a list of XP operators, u is a vector of integer
def GeneratorProduct(S,u,N):
    if len(S) == 0:
        return None
    n = XPn(S)
    u = np.mod(u,2*N)
    temp = XPI(n)
    for j in range(min(len(S),len(u))):
        uj = u[j]
        Sj = S[j]
        if uj >= 1:
            temp = XPMul(temp,XPPower(Sj,N,uj),N)
    return temp

## Canonical generators for set of XP operators G of precision N
def CanonicalGenerators(G,N,C=False):
    if C is not False:
        SC,SG = XPSpan(C,N),XPSpan(G,N)
        return ZMatEqual(SC,SG)
    n = XPn(G)
    ## Simplify X component
    S = simplifyX(G,N)
    ## Split into diag and non-diag operators
    SX,SZ = splitDiag(S)
    ## Add squares and commutators of SX
    toDo = [SZ]
    # report('Adding Squares and Commutators of SX')
    for A in SX:
        Sq = XPSquare(A,N)
        toDo.append(Sq)
        Comm = XPCommutator(A,SX,N)
        toDo.append(Comm)
    SZ = np.vstack(toDo)
    ## Simplify Z component
    SZ = simplifyZ(SZ,N)

    ## Add commutators between SX and SZ
    ## need to repeat t times
    t = max(0,logCeil(N-1,2))
    toDo = [SZ]
    for i in range(t-1):
        ## Commutators Level i+1
        for A in SX:
            ## commutators between X operators and Z operators
            toDo.append(XPCommutator(A,SZ,N))
        SZ = np.vstack(toDo)
        ## Simplify Z component
        SZ = simplifyZ(SZ,N)
    
    ## Simplify Z component of SX
    SX = simplifyXZ(SX,SZ,N)

    return np.vstack([SX,SZ])

## check whether list of operators in canonical form S is admissible
## ie has any members with fundamental phase not equal to zero
def Admissible(S,N):
    f,d = XPFundamentalPhase(S,N)
    return np.all(f==0)


## Coset (Eq + u @ LXx) mod 2 where wt(u) <= w
## Also returns Qindex and Lindex 
def coset(Eq,LXx,w=None):
    k,n = np.shape(LXx)
    Et, Lindex, Qindex = [],[],[]
    w = k if w is None else min(k,w)
    for u in BinPowerset(k,w):
        for i in range(len(Eq)):
            Qindex.append(i)
            Lindex.append(u)
            Et.append(np.mod(Eq[i] + u @ LXx,2))
    return ZMat(Et,n),ZMat(Qindex,1),ZMat(Lindex,k)

## T is the set of binary vectors x such that Em + x = Em
def getT(Em):
    m0 = Em[0]
    n = len(m0)
    Em = ZMat(Em,n)
    EmSet = {tuple(m) for m in Em}
    Em0 = [np.mod(m - m0,2) for m in Em[1:]]
    T = []
    for x in Em0:
        Emx = np.mod(Em + x,2)
        if np.all([tuple(m) in EmSet for m in Emx]):
            T.append(x)
    return ZMat(T,n)

## Decomposition Em = Eq + <LXx>
## also returns QIndex, LIndex
def cosetDecomposition(Em):
    Em = ZMat(Em)
    m,n = np.shape(Em)
    ## get valid transitions
    LXx = getT(Em)
    report('T')
    report(ZmatPrint(LXx,2),"\n")
    
    ## get RREF of T
    if len(LXx) > 0:
        Eq,LIndex,QIndex = [],[],[]
        Xnsp = NSpace(LXx,2)
        LXx = RemoveZeroRows(Xnsp.H)
        Eq = set()
        qCount = 0
        for e in Em:
            q,u = matResidual(LXx,e,2)
            q = tuple(q)
            Eq.add(q)
            QIndex.append(q)
            LIndex.append(u)
    else:
        QIndex = [tuple(e) for e in Em]
        Eq,LIndex,QIndex = QIndex,[[0]]*m,QIndex
    Eq = sorted(Eq)
    EqDict = {Eq[i]:i for i in range(len(Eq))}
    QIndex = [EqDict[e] for e in QIndex]
    Eq,LXx,LIndex,QIndex = ZMat(Eq,n),ZMat(LXx,n),ZMat(LIndex,n),ZMat(QIndex,n)
    report('LXx is RREF(T)')
    report(ZmatPrint(LXx,2),"\n")
    return Eq,LXx,QIndex,LIndex  

## orbit representatives Em
def getEm(S,N,check=False):
    n = XPn(S)
    if not Admissible(S,N):
        print('Generators are not admissible')
        return None
    SX,SZ = splitDiag(S)

    #### Calculate x: Set representing leading indices of X-component
    li = leadingIndices(XPx(SX))
    x = ZMat([2]*(n+1))
    x[li] = 0
    x[-1] = 1
    report('x',x,"\n")

    ## array of Z and phase components
    Szp = XP2Zp(SZ,N,double=False)
    report('Szp')
    report(ZmatPrint(Szp,N),"\n")

    ##### Testing
    if check is not False:
        # report('Checking Em')
        # report('Em',check)
        E = binSolveNaive(Szp,N,1,x)
        # report('solveNaive',E)
        return spaceSig(E) == spaceSig(check)

    # make NSpace modulo N from Szp
    nsp = NSpace(Szp,N)

    # make the kernel of A into a Howell basis
    nsp.simplifyKer()
    K = nsp.K
    report('K')
    report(ZmatPrint(K,N),"\n")
    
    ###### Calculate the solution graph D by calling espaceSolve
    # D is the graph
    # (n,b) is the starting node for the solution
    D,(n,b) = espaceSolve(K,N,b=None,x=x)

    ###### convert graph D to a list L
    # L is a list of vectors c modulo N of length m
    # representing linear combinations of the rows of K
    A = graph2List(D,(n,b),rev=True)
    A = ZMat(A)
    report('A')
    report(ZmatPrint(A,N),"\n")

    ###### Convert L to list of binary vectors B - these are the solutions
    Em = ZMat([np.mod(a @ K, N) for a in A])
    
    ## Include only elements with 1 in -1 position
    ix = [i for i in range(len(Em)) if Em[i][-1]==1]
    Em = Em[ix]
    ## remove last column
    Em = Em[:,:-1]
    report('Em',Em)
    return Em

## Orbit operator - SIndex weight less than t
def OrbitOperator(SX,N,t=None):
    n = XPn(SX)
    SIndex, OSx = ZMat([[]]),ZMat([XPI(n)])
    k = len(SX)
    t = k+1 if t is None else min(t,k+1) 
    report(func_name(),'t',t)       
    for i in range(k):
        ix = [i for i in range(len(SIndex)) if weight(SIndex[i]) < t-1]
        # report(func_name(),'SIndex')
        # report(ZmatPrint(Sindex,2))
        # report('ix',ix)
        # Sindex = np.vstack([np.hstack([Sindex,0]), np.hstack([Sindex[ix],1])])
        col0 = np.zeros((len(SIndex),1),dtype=int)
        col1 = np.ones((len(ix),1),dtype=int)
        SIndex = np.vstack([np.hstack([SIndex,col0]), np.hstack([SIndex[ix],col1])])
        OSx = np.vstack([OSx,XPMul(OSx[ix],SX[i],N)])
    report('OSx')
    report(XP2Str(OSx,N),"\n")
    if np.size(SIndex) ==0:
        SIndex = ZMat([[0]])
    return OSx,SIndex

## codewords orbit distance less than t from Em
## can also be used for Eq/GX
def getCodewords(EmState,SX,N,t=None):
    OSx,SIndex = OrbitOperator(SX,N,t)
    return ZMat([XPMul(OSx,m,N) for m in EmState]),SIndex

def checkCodewords(codeWords,G,N):
    G = ZMat2D(G)
    valid = True
    for b in codeWords:
        for g in G:
            s = XPMul(g,b,N)
            if not StateEqual(s,b):
                report('Codeword')
                report(State2Str(b,N))
                report('Generator',XP2Str(g,N))
                report('XPMul(g,b,N)')
                report(State2Str(s,N))
                valid = False
    return valid

## Return NSpace to calculate Logical Identities/Operators
## Codewords can be partial (eg orbit distance t from Em for Logical Operators)
def getNsp(CW,N):
    # report(func_name(),ZMat2tuple(CW))
    m = len(CW)
    EL = []
    for i in range(m):
        x = XPx(CW[i])
        ## Logical Index
        ix = [set2Bin(m,[i])]*len(x)
        EL.append(np.hstack([x,ix]))
    EL = np.vstack(EL)
    report('EL')
    report(ZmatPrint(EL,2),"\n")
    nsp = NSpace(EL,N)
    nsp.simplifyKer()
    report('KL')
    report(ZmatPrint(nsp.K,N),"\n")
    return nsp

## Calculate Logical Identity generators M in canonical form
## Assuming we have canonical generators SX
def getLI(SX,nsp,N,n):        
    ## diagonal operators MZ correspond to Ker
    MZ = Zp2XP(nsp.K,N,double=False)
    ## take residue of Z components of SX
    MX = simplifyXZ(SX,MZ,N)
    return np.vstack([MX,MZ]) 

## Calculate Logical Operators generators L in canonical form
## Assuming we have already calculated LX
def getLO(LX,nsp,N,n):
    z,F = nsp.K[:,:n],nsp.K[:,n:]
    report(func_name(), nsp.K)
    LZ = makeXP(0,0,z)
    LX = simplifyXZ(LX,LZ,N)
    ## remove non-trivial diagonal operators
    LZ = ZMat([LZ[i] for i in range(len(LZ)) if not(isConstant(F[i]))],2*n+1)
    return np.vstack([LX,LZ]) 


## Calculate non-diagonal logical operators from Codewords
def CW2LX(CW,LXx,nsp,N):
    n = XPn(CW[0])
    LX = []
    ## make dictionary from codewords - phase and codeword
    CWphases = CW2Dict(CW)
    # report(func_name())
    # for e,p in CWphases.items():
    #     report(e,p)
    for x in LXx:
        A = getLX(x,CW,CWphases,nsp,N)
        if A is not False:
            LX.append(A)
    return ZMat(LX,2*n+1)

def getLX(x,CW,CWphases,nsp,N):
    # report(func_name(),x)
    n = XPn(CW[0])
    ## change in phase applied by XP_N(0|x|0)
    Deltap = []
    ## adjustment factor - either 0 or 1
    a = []
    for i in range(len(CW)):
        p0,x0,z0 = XPcomponents(CW[i])
        # report('x0',x0)
        x1 = np.mod(x0+x,2)
        p1 = ZMat([CWphases[tuple(e)] for e in x1])
        dp = np.mod(p1 - p0,2*N)
        # report('dp',dp)
        ## adjust precision of phase to N
        if N % 2 ==0:
            ## change in phase modulo 2 should be the same for all basis elts in codeword
            dpmod2 = set(np.mod(dp,2))
            if len(dpmod2) > 1:
                report(func_name(),'change in phase modulo 2 not constant for codeword')
                return False
            ai = dpmod2.pop()
            ## we adjust by subtracting ai and divide by 2
            dp = (dp - ai)//2
        else:
            ## use ring division - 2 is a unit in this case
            ai=0
            dp = vDiv(dp,2,N)
        a.append(ai)
        Deltap.append(dp)
    Deltap = np.hstack(Deltap)
    # report('Deltap',Deltap)
    ## try to find a valid z component
    k,o = nsp.makeOffset(Deltap)
    if not(isZero(o)):
        ## cannot find a solution
        report(func_name(),'makeOffset failed')
        return False
    else:
        ## get z component and phase vector
        z,f = k[:n],k[n:]
        ## adjust the overall phase of the operator - but only if size of f is 1:
        if len(f) > 1:
            p = 0
        else:
            ## we know adjustment a is constant and f has one element
            ## adjust to modulo 2N
            p = np.mod(a[0] + 2*f[0],2*N)
        return makeXP(p,x,z)


def ActionSolve(la,LD,FD,N):
    r,u = matResidual(FD,la,2*N)
    if isZero(r):
        Zp = XP2Zp(LD,N)
        A = matMul(u,Zp,2*N)
        return Zp2XP(A,N)
    return None

## ensure that A^2 in <MZz>
def X2Solve(x,b,LZz,MZz,N):
    x = np.append(x,0)
    # report(func_name(),'x',x)
    Sxp = np.diag(x)
    Sxn = np.diag(1-x)
    Sp0 = nsIntersection([MZz,Sxn],2*N)
    # report(func_name(),'Sp0')
    # report(ZmatPrint(Sp0))
    Sp0 = nsUnion([Sp0,N * Sxn,Sxp],2*N)
    # report(func_name(),'Sp0')
    # report(ZmatPrint(Sp0))
    b0 = ZMatZeros(len(x))
    # report('b0',b0)
    return affineIntercept(LZz,b,Sp0,b0,2*N)

def minDistance(G):
    D = [XPdistance(op) for op in G]
    return min(D)

############

def isLO(L,LI,N):
    for A in LI:
        C = XPCommutator(A,L,N)
        # report(XP2Str(C,N))
        R,u = XPResidual(LI,C,N)
        # report(XP2Str(R,N)) 
        if not XPisI(R):
            report(func_name(),XP2Str(L,N),XP2Str(A,N),XP2Str(C,N),XP2Str(R,N))
            return False
    return True

## main class for XP codes
class Code:

    ## set defaults for new code
    ## G is a list of XP operators
    ## N is the precision 
    def __init__(self,G,N):
        self.N = N
        self.n = XPn(G)
        self.G = ZMat2D(G) 
    
    ## S is the canonical generators
    def getS(self):
        S = CanonicalGenerators(self.G,self.N)
        SX,SZ = splitDiag(S)
        setVals(self,['SX','SZ','SXx'],[SX,SZ,XPx(SX)])
        return S

    def getEm(self):
        Em = getEm(getVal(self,'S'),self.N)
        report(func_name(),'Em')
        report(Em)
        EmState = makeXP(0,Em,0)
        # report(func_name(),State2Str(EmState,self.N))
        setVal(self,'EmState',EmState)
        return Em

    ## core Eq
    def getEq(self):
        Em,EmState = getVals(self,['Em','EmState'])
        Eq,LXx,QIndex,LIndex = cosetDecomposition(Em)
        # report(func_name(),'LXx',LXx)
        ## sort order for Em, QIndex, LIndex
        EmOrder = [(weight(LIndex[i]),) + tuple(LIndex[i]) + (QIndex[i],) for i in range(len(LIndex))]
        ix = argsort(EmOrder)
        EqState = makeXP(0,Eq,0)
        ## set values for 'EqState','Em','EmState','LXx','QIndex','LIndex'
        setVals(self,['EqState','Em','EmState','LXx','QIndex','LIndex'],[EqState,Em[ix],EmState[ix],LXx,QIndex[ix],LIndex[ix]])
        return Eq
        
    def getCodewords(self,check=False):
        S,EmState = getVals(self,['S','EmState'])
        SX,SZ = splitDiag(S)
        C,SIndex = getCodewords(EmState,SX,self.N)
        setVal(self,'SIndex',SIndex)
        return C

    def displayE(self):
        Codewords, QIndex,LIndex,SIndex = getVals(self,['Codewords', 'QIndex','LIndex','SIndex'])
        E = [ZMat2str(XPx(c)) for c in Codewords]
        SIndex = ZMat2str(SIndex)
        LIndex = ZMat2str(LIndex)
        QIndex = np.char.mod('%d', QIndex)
        labels = []
        body = []
        labels.append(["","SIndex"])
        body.append(SIndex)
        labels.append(['QIndex','LIndex'])
        body.append([""]*len(SIndex))
        for i in range(len(QIndex)):
            labels.append([QIndex[i],LIndex[i]])
            body.append(E[i])
        data = np.hstack([labels,body])
        return ZmatTable(data,[2],[2])

    ## codewords orbit distance t = log2(N) from Eq
    ## for calculating Logical Identities and Regular Generators
    def getCWI(self,N):
        EqState, LXx, SXx = getVals(self,['EqState', 'LXx', 'SXx'])
        
        ## we don't care about phases for CWI
        x = np.vstack([SXx,LXx])
        GX = makeXP(0,x,0)

        ## make codewords less than orbit distance t from Eq
        t = logCeil(N-1,2) 
        t = t+1 if 2 ** t == N else None
        # report('t',t)
        CWI, SIndex = getCodewords(EqState,GX,N,t)
        ## merge into one single codeword
        return ZMat([np.vstack(CWI)])

    ## codewords orbit distance t = log2(N) from Em
    ## for calculating Logical Operators
    def getCWL(self,N):
        Em,EmState, SX = getVals(self,['Em','EmState', 'SX'])
      
        ## make codewords less than orbit distance t from Eq
        t = logCeil(N-1,2) 
        t = t+1 if 2 ** t == N else None
        report('t',t)
        CWL, SIndex = getCodewords(EmState,SX,N,t)
        return CWL

    def getLI(self):
        N = self.N
        SX = getVal(self,'SX')
        CWI = self.getCWI(N)
        nsp = getNsp(CWI,N)
        return getLI(SX,nsp,N,self.n)

    def getLO(self):
        report(func_name())
        N = self.N
        Em,Eq,LXx = getVals(self,['Em','Eq','LXx'])
        CWL = self.getCWL(N)
        report('CWL')
        for c in CWL:
            report(State2Str(c,N))
        nsp = getNsp(CWL,N)
        
        # report('LXx',LXx)
        LX = CW2LX(CWL,LXx,nsp,N)
        report('LX',np.shape(LX))
        return getLO(LX,nsp,N,self.n)

    def Fvector(self,A):
        EmState = getVal(self,'EmState')
        return Fvector(A,EmState,self.N)

    def analyseLO(self,A):
        N = self.N
        temp = ['Analysing: ' + XP2Str(A,self.N)] 
        ## check if A is a logical operator
        M = getVal(self,'LI')
        if not isLO(A,M,N):
            temp.append("Not a Logical Operator")
        else:
            temp.append('Is a Logical Operator')
            ## get F vector and reshape intro rows with same LIndex
            QIndex,LIndex,EmState = getVals(self,['QIndex','LIndex','EmState'])
            LIndex = ZMat2str(LIndex)
            QIndex = np.char.mod('%6d', QIndex)
            LIndex, Lix = np.unique(LIndex, return_index=True)
            QIndex, Qix = np.unique(QIndex, return_index=True)

            f = Fvector(A,EmState,N)
            temp.append("F vector: " + str(f))
            f = np.reshape(f,(len(LIndex),len(QIndex)))
            f = np.char.mod('%d', f)

            ## create table
            labels = []
            body = []
            labels.append("")
            body.append(['QIndex'] + [''] * (len(QIndex)-1))
            labels.append('LIndex')
            body.append(QIndex)
            for i in range(len(LIndex)):
                labels.append(LIndex[i])
                body.append(f[i])
            labels = np.transpose([labels])
            data = np.hstack([labels,body])
            temp.append('Regular/Core Analysis:')
            temp.append(ZmatTable(data,[2],[1])) 
        return "\n".join(temp)

    def getwI(self):
        wI = ZMatZeros(2*self.n+1)
        wI[-1] = 1
        return wI

    def getLD(self):
        L,EmState,wI = getVals(self,['LO','EmState','wI'])
        LX,LZ = splitDiag(L)
        LZ = np.vstack([wI,LZ])
        FZ = [Fvector(A,EmState,self.N) for A in LZ]
        nsp = NSpace(FZ,2*N)
        nsp.simplifyH()
        FD = nsp.getVal('H')
        U = nsp.getVal('P')
        Zp = XP2Zp(LZ,N)
        Zp = matMul(U,Zp,2*N)
        LD = Zp2XP(Zp,N)
        LD = RemoveZeroRows(LD)
        setVal(self,'FD',FD)
        return LD

    ## map regular code to CSS code with similar LO structure
    def getR(self):
        Eq = getVal(self,'Eq')
        ## check if regular
        if len(Eq) > 1:
            return False
        ## Calculate RX: regular non-diagional generators
        SXx = getVal(self,'SXx')
        RX = makeXP(0,SXx,0) 
        ## CWI: codewords at most orbit distance 1 from Eq       
        N=2
        CWI = self.getCWI(N)
        nsp = getNsp(CWI,N)
        return getLI(RX,nsp,N,self.n)

    def getdimension(self):
        Em = getVal(self,'Em')
        return len(Em)

    def getdistance(self):
        M = getVal(self,'LI')
        L = getVal(self,'LO')
        ML = XPSpan(np.vstack([M,L]),self.N)
        return minDistance(ML)


    def getLogicalZ(self):
        LIndex,LD,FD = getVals(self,['LIndex','LD','FD'])
        LogicalZ = []
        if len(LIndex) == 0:
            return LogicalZ
        else:
            k = len(LIndex[0])
            for i in range(k):
                la = LIndex[:,i] * N
                A = ActionSolve(la,LD,FD,self.N)
                if A is not None:
                    LogicalZ.append(A)
        return ZMat(LogicalZ,2*self.n+1)

    def getLogicalX(self):
        LI,LO,wI,EqState = getVals(self,['LI','LO','wI','EqState'])
        N = self.N
        MX,MZ = splitDiag(LI)
        LX,LZ = splitDiag(LO)
        LogicalX = []
        LZz,MZz = XP2Zp(LZ,N),XP2Zp(MZ,N)
        for A in LX:
            b = XP2Zp(A,N)
            x = XPx(A)
            r = X2Solve(x,b,LZz,MZz,N)
            # report('r',r)
            if r is not False:
                B = Zp2XP(r,N)
                p,x1,z = XPcomponents(B)
                A = makeXP(p,x,z)
            A2 = XPSquare(A,N)
            A2 = XP2Zp(A2,N)
            r,u = matResidual(MZz,A2,2*N)
            A2 = Zp2XP(r,N)
            # report(func_name(),'A2',XP2Str(A2,N))
            p = np.mod(-XPp(A2)//2,2*N)
            A = XPMul(A,p*wI,N)
            LogicalX.append(A)

        LogicalX = ZMat(LogicalX,2*self.n+1)
        # X2 = XPSquare(LogicalX,N)
        # report('X2')
        # report(XP2Str(X2,N))
        EmState, SIndex = getCodewords(EqState,LogicalX,N)
        EmState = ZMat2D(EmState) 
        # report(func_name(),'EmState')
        # report(State2Str(EmState,N))
        setVal(self,'EmState',EmState)
        return LogicalX

#################################        
##        Measurements         ##
################################# 

def Par(x,z):
    return matMul(z,np.transpose(x),2)[0]

def MeasureDiagPauli(Eq,SX,LX,z,N):
    report(func_name(),np.shape(SX),np.shape(LX))
    ## get X components of SX,LX
    SXx,LXx = XPx(SX),XPx(LX)
    ## split SX into parity 0/1 operators
    ix = Par(SXx,z)
    # report('ix',ix)
    SX,SX1 = SX[ix==0],SX[ix==1]
    # report('SX,SX1',SX,SX1)
    ## split LX into parity 0/1 operators
    ix = Par(LXx,z)
    LX,LX1 = LX[ix==0],LX[ix==1]
    ## find parity 1 operator B
    B = None
    if len(SX1) > 0:
        B = SX1[0]
        SX1 = np.delete(SX1,0,axis=0)
    if B is None and len(LX1) > 0:
        B = LX1[0]
        LX1 = np.delete(LX1,0,axis=0)
    ## update SX,LX,Eq if B is found
    if B is not None:
        ## Update Eq
        x = XPx(B)
        Eq = np.vstack([Eq,np.mod(Eq+x,2)])
        ## Update SX
        if len(SX1) > 0:
            SX1 = XPMul(B,SX1,N)
            SX = np.vstack([SX,SX1])
        ## Update LX
        if len(LX1) > 0:
            LX1 = XPMul(B,LX1,N)
            LX = np.vstack([LX,LX1])
    nEq = len(Eq)
    ## split Eq into parity 0/1 vectors
    ix = Par(Eq,z)
    Eq0,Eq1 = Eq[ix==0],Eq[ix==1]
    ## return updated core format for outcome +1 and -1
    return (Eq0,SX,LX,len(Eq0)/nEq),(Eq1,SX,LX,len(Eq1)/nEq)

#################################        
##   Simultaneous Eigenspaces  ##
#################################  

## hashable signature of eigenspace
def spaceSig(L):
    temp = [tuple(l) for l in L]
    return tuple(sorted(temp))

## text version of eigenspace
def spaceTxt(L):
    T = ["".join(map(str,x)) for x in L]
    return "\\".join(T)+ "\\"

## solve for Ae = p
# A is m x n matrix modulo N
# p is a length m string modulo N representing phases
# x is a list of indices 0 <= i < n where we require e[i] = 0
# output [e] are is a length n binary string
def binSolve(A,N,p=None,x=None,check = False):
    # no rows in A, return empty list
    if len(A) == 0:
        return []
    # default for p vector
    if p is None:
        p = [0] * len(A)
    # default for x vector
    if x is None:
        x = []
    x = set(x)
    # make NSpace modulo N from A
    nsp = NSpace(A,N)
    # make an offset b - solutions modulo N are in the format
    # x = b + k where k in Ker(A)
    b,o = nsp.makeOffset(p)

    # if o[c] > 0 for some c, then there is no solution
    if not isZero(o,N):
        return []
    # convert b to list format
    b = mat2list(b)
    # make the kernel of A into a Howell basis
    nsp.simplifyKer()
    K = nsp.K
    b,ix = matResidual(K,b,N)
    # check is for testing
    if check is not False:
        report('Checking binSolve')
        report('binSolve',check)
        E = binSolveNaive(A,N,p,x)
        report('solveNaive',E)
        return spaceSig(E) == spaceSig(check)
    # call espaceSolve
    # D is the graph
    # (n,b) is the starting node for the solution
    D,(n,b) = espaceSolve(K,N,b=b,x=x)
    # convert graph D to a list L
    L = graph2List(D,(n,b),rev=True)
    L = ZMat(L)
    # report('L',L)
    # L is a list of vectors c modulo N of length m
    # representing linear combinations of the rows of K
    # Convert these to binary vectors B
    if len(L):
        B = [np.mod(a @ K + b, N) for a in L]
    else:
        B = []
        if np.all([i < 2 for i in b]):
            B.append(b)
    return ZMat(B)

# ## Incremenet binary row
def binRowInc(val):
    carry = 1
    i = len(val) - 1
    while carry > 0 and i > -1:
        if val[i] == 1:
            val[i] = 0
        else:
            val[i] = 1
            carry = 0
        i = i -1
    return val

def binSpliceZeros(val,x):
    ## splice zeros into positions indicated by x
    temp = []
    ## i is the counter for position in val
    i = 0
    ## j is the counter for position in temp
    for j in range(len(val) + len(x)):
        ## if j in x, we need to have a zero in this position
        if j in x:
            temp.append(0)
        else:
            ## check if i is a valid counter for val
            if i < len(val):
                temp.append(val[i])
                i+=1
    return temp

# solve for Ax = p in binary strings
# positions indicated by x are zero
def binSolveNaive(A,N,p,x):
    temp = []
    m = len(A)
    if m == 0:
        ## nothing to check - return empty array
        return temp
    if p is None:
        ## phase to solve for p = 1 by default
        p = [0]* m
    ## ensure 0 <= p < N
    p = np.mod(p,N)
    ## make sure that all entries in x are valid
    x = [i for i in x if i < len(A[0])]
    ## all entries in x are zero, so fewer options to check
    n = len(A[0]) - len(x)
    ## initial value of e - 0
    e = [0] * n
    for k in range(1 << n):
        ## splice zeros into positions indicated by x
        ex = binSpliceZeros(e,x)
        ex = ZMat(ex)
        r = 0
        valid = True
        ## check phase for each row of A
        while r < len(A) and valid:
            ## multiply ex by A[r], modulo N
            if np.sum(ex * A[r]) % N != p[r]:
                valid = False
            r += 1
        if valid:
            temp.append(ex)
        ## next value of e
        e = binRowInc(e)
    return ZMat(temp)

## generic graph to list
def graph2List(D,ix=None,rev=False,s=tuple()):
    if ix is None:
        ix = max(D.keys())
    temp = []
    (n,p) = ix
    if ix in D:
        if len(D[ix]):
            for d,p1 in D[ix].items():
                s1 = s+(d,) if rev else (d,)+s
                n1 = n+1 if rev else n-1
                if p1 is not None:
                    temp += graph2List(D,(n1,p1),rev,s1)
                else:
                    temp.append(s1)
    return temp

## print generic graph
def printGraph(D):
    nodeCount = dict()
    # KList = sorted(D.keys(),reverse=True)
    KList = D.keys()
    for k in KList:
        L = len(D[k])
        # if L > 0:
            # report(k,D[k])
        if L not in nodeCount:
            nodeCount[L] = 1
        else:
            nodeCount[L] += 1
    m = max(nodeCount.keys())+1
    nodeCount = [nodeCount[i] if i in nodeCount else 0 for i in range(m)]
    report('nodeCount',nodeCount)
    report('total Nodes',sum(nodeCount))

def leadingIndices(K):
    n = len(K)
    if n == 0:
        return []
    L = [len(K[0])] * (n)
    m = len(K[0])
    i = 0
    j = 0
    while i < m and j < n:
        if K[j][i] == 0:
            i += 1
        else:
            L[j] = i
            j+=1
            # i+=1
    return L

# zeroCols[r] = [c] where K[r][c] = 0 for all r
def zeroCols(K):
    m = len(K)
    if m ==0:
        # no rows, return empty list
        return []
    # length of first row of K
    n = len(K[0])
    # colSetRows[c] = [r] such that K[r][c] > 0
    colSetRows = [[r for r in range(m) if K[r][c] > 0] for c in range(n)]
    return [c for c in range(n) if len(colSetRows[c]) == 0]

# lowestCols[r] = [c] where K[r][c] > 0 and K[s][c] = 0 for all s > r
# If binarising, when we get to row r of K, b[c] must all be 0 or 1 
# as this is the last row where the b[c] can change
def lowestCols(K):
    m = len(K)
    if m ==0:
        # no rows, return empty list
        return []
    # length of first row of K
    n = len(K[0])
    # colSetRows[c] = [r] such that K[r][c] > 0
    colSetRows = [[r for r in range(m) if K[r][c] > 0] for c in range(n)]
    # temp is a vector of length m = len(K)
    temp = [[] for r in range(m)]
    for c in range(n):
        # check if there are any rows r where K[r][c] > 0
        if len(colSetRows[c]) > 0:
            # r is the largest such that K[r][c] > 0
            r = max(colSetRows[c])
            # append c to the list for row r
            temp[r].append(c)
    return temp

# Solve for e = b + cK for vector c such that:
# 0 <= c[i] < N, 0 <= i < len(K)
# e a binary vector, e[x] = 0
def espaceSolve(K,N,b=None,x=None):
    K = ZMat(K)
    m,n = np.shape(K)
    # report('K')
    # report(K)
    # set defaults for vector x
    if x is None:
        x = [None]*n    
    # x = set(x)
    # set defaults for vector b
    if b is None:
        b = [0]*n
    # starting node = ix
    # starting row of K=0
    # residual vector=b 
    ix = (0,tuple(b))
    # initialize graph
    D = dict()

    # get lowestCols of K
    LC = lowestCols(K)
    # call recursive function espaceGraph
    temp = espaceGraph(K,N,x,ix,D,LC)
    # return the graph D and starting node ix
    return D,ix
		
## graph solution of eigenspace of operator list K
def espaceGraph(K,N,x,ix,D,LC):
    if ix in D:
        return D[ix]
    temp = dict()
    # r: row number of K
    # b0: residual vector we are seeking to binarise
    r,b0 = ix
    # L: lowestCols; Lr = lowestCols[r]
    Lr = LC[r]
    # l: index of leading nonzero entry of K[r]
    li = Lr[0]
    # p: corresponding entry in b0 - needs to be 0 or 1
    p = b0[li]
    # k: corresponding entry in K[r]
    k = K[r][li]
    # cList: possible values c such that p + k * c = 0/1 mod N
    aList = []

    if x[li] != 1 and p % k  == 0:
        # in this case, we can make p + k * c = 0
        a = ((N-p)//k) % N
        aList.append(a)
    if x[li] != 0 and (p-1) % k == 0:
        # in this case, we can make p + k * c = 1
        # if l in x, then only 0 is allowed
        a = ((N+1-p)//k) % N
        aList.append(a)
    if len(aList):
        b0 = ZMat(b0)
        PSet = {}
        for a in aList:
            # b1 is b0 + c * K[r]
            b1 = np.mod(b0 + a * K[r],N)
            # b1[l] = 0
            valid = True 
            i = 1
            while valid and i < len(Lr):
                j = Lr[i]
                valid = b1[j] < 1 if j in x else b1[j] < 2
                # if j in x, then only 0 is allowed for b1[j]
                # otherwise, either 0 or 1 is allowed
                # b1[j] = 0
                i += 1
            if valid:
                # set b1 corresponding to Lr to zero - these are all 0 or 1
                b1[Lr] = 0
                PSet[a] = tuple(b1)
        if r == len(K) - 1:
            # in this case, we are at the last row of K
            for a,b1 in PSet.items():
                # base case - no recursion required
                temp[a] = None
        else:
            for a,b1 in PSet.items():
                # recursion - s = solutions for r+1, for vector b1
                s = espaceGraph(K,N,x,(r+1,b1),D,LC)
                if len(s):
                    # if there are valid solutions, create a link in the node
                    temp[a] = b1
    # update the solutions graph
    D[ix] = temp
    return temp 

# setVerbose(True)

# ## Code 1
# # genstr = 'XP_8(8|0000000|6554444),XP_8(7|1111111|1241234),XP_8(1|1110000|3134444)'

# ## Code 2
# genstr = 'XP8(0|0000000|1322224)\nXP8(12|1111111|1234567)'

# ## Single Stabilizer - no nondiagonal stabilizers
# # genstr = 'XP8(0|0000000|1322224)'

# ## Two nondiagonal Stabilizers - no nondiagonal LOs
# # genstr = 'XP8(0|0000000|1322224)\nXP8(12|1111111|1234567)\nXP_8( 0|0011110|0012304)'

# G, N = str2XP(genstr)
# report('Generators')
# report(XP2Str(G,N),"\n")

# C = Code(G,N)
# S = getVal(C,'S')
# report('CanonicalGenerators')
# report(XP2Str(S,N),"\n")
# report('Checking CanonicalGenerators:',CanonicalGenerators(G,N,S))
# report('Admissible',Admissible(S,N),"\n")

# Em = getVal(C,'Em')
# report('Em')
# report(ZmatPrint(Em,2),"\n")

# Eq = getVal(C,'Eq')
# report('Eq')
# report(ZmatPrint(Eq,2),"\n")

# CW = getVal(C,'Codewords')
# report('Codewords')
# for c in CW:
#     report(State2Str(c,N))
# report('Checking Codewords',checkCodewords(CW,G,N))
# report("\n")

# report("E in index form")
# report(C.displayE(),"\n")

# M = getVal(C,"LI")
# report('Logical Identity Generators')
# report(XP2Str(M,N))

# MEm = getEm(M,N)
# print('M Em')
# print(ZmatPrint(MEm,2))

# report('Check if XP-Regular and Map to CSS code')

# R = getVal(C,'R')
# if R is not False:
#     print('R')
#     print(XP2Str(R,2))
#     REm = getEm(R,2)
#     print('R Em')
#     print(ZmatPrint(REm,2))
# else:
#     print('Code is not Regular')

# L = getVal(C,"LO")
# report('Logical Group Generators')
# report(XP2Str(L,N),"\n")

# for A in L:
#     report(C.analyseLO(A),"\n")


# LD,FD = getVals(C,['LD','FD'])
# report('FD')
# report(FD,"\n")
# report('LD')
# report(XP2Str(LD,N),"\n")

# EmState = getVal(C, 'EmState')

# LogicalZ = getVal(C,'LogicalZ')
# report('Logical Z Operators')
# for A in LogicalZ:
#     report(XP2Str(A,N),isLO(A,M,N),'f',Fvector(A,EmState,N))

# LogicalX = getVal(C,'LogicalX')
# EmState = getVal(C, 'EmState')
# report('Logical X Operators')
# for A in LogicalX:
#     report(XP2Str(A,N),isLO(A,M,N),'f',Fvector(A,EmState,N))

# Astr = 'XP_2( 0|0000000|0111111)'
# # Astr = 'XP_2( 0|0000000|0000100)'
# A,P = str2XP(Astr)
# z = XPz(A)
# print('Measuring',XP2Str(A,P))
# SX,LX = getVals(C,['SX','LogicalX'])
# res = MeasureDiagPauli(Eq,SX,LX,z,N)
# signs = ['+','-']
# for i in range(2):
#     Eqr,SXr,LXr,Pr = res[i]
#     print(signs[i],'1 Outcome Probability:',Pr)
#     print('Eq')
#     print(ZmatPrint(Eqr))
#     print('SX')
#     print(XP2Str(SXr,N))
#     print('LX')
#     print(XP2Str(LXr,N))    

