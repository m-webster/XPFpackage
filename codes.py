import numpy as np
from common import *
from NSpace import *
from XPAlgebra import *
import itertools

## XP group generated by set of XP operators S of precision N
def XPSpan(S,N):
    ## G is the group generated
    G = []
    ## U - set to avoid duplications in G
    U = set()
    ## raise non-diagonals to either 0 or 1 power
    ## raise diagonals to [0..d-1]    
    maxPowers = [range(XPDegree(A,N)) if XPisDiag(A) else range(2) for A in S]
    for t in itertools.product(*maxPowers):
        g = None
        for i in range(len(maxPowers)):
            h = XPPower(S[i],N,t[i])
            g = h if g is None else XPMul(g,h,N)
        t = tuple(g)
        if t not in U:
            G.append(g)
            U.add(t)
    return G

## XP group generated by set of XP operators S of precision N
# def XPSpanold(S,N):
#     ## G is the group generated
#     G = []
#     ## U - set to avoid duplications in G
#     U = set()
#     ## raise non-diagonals to either 0 or 1 power
#     ## raise diagonals to [0..d-1]    
#     opts = [XPDegree(A,N) if XPisDiag(A) else 2 for A in S]
#     for x in range(np.prod(opts)):
#         t = int2tuple(x,opts)
#         g = None
#         for i in range(len(opts)):
#             h = XPPower(S[i],N,t[i])
#             g = h if g is None else XPMul(g,h,N)
#         t = tuple(g)
#         if t not in U:
#             G.append(g)
#             U.add(t)
#     return G

## split XP operators into non-diagonal and diagonal operators
def splitDiag(G):
    S = [[],[]]
    n = XPn(S)
    for g in G:
        i = 1 if XPisDiag(g) else 0
        S[i].append(g)
    return [ZMat(S[i],n) for i in range(2)]

## Simplify X components of XP operators G of precision N
def simplifyX(G,N):
    ## split into diagonal and non-diagonal operators
    Sx,Sz = splitDiag(G)
    ## make RREF of X-components
    A = XPx(Sx)
    nsp = NSpace(A,2)
    ## U is the transformation matrix
    U = nsp.getVal('P')
    ## corresponding group operations on Sx
    Sx = doOperations(Sx,U,N)
    Sx = RemoveZeroRows(Sx)
    ## return both updated Sx and Sz
    return np.vstack([Sx,Sz])

## simplify Z components of Sz
def simplifyZ(Sz,N):
    Sz = RemoveZeroRows(Sz)
    ## A is 2*z|p
    A = XP2Zp(Sz,N)
    ## get Howell basis
    nsp = NSpace(A,2 * N)
    H = nsp.getVal('H')
    H = RemoveZeroRows(H)
    ## convert back to operators
    Sz = Zp2XP(H,N)
    return Sz

## vectorized version of Div
vDiv = np.vectorize(Div)
    
## return z and p components in single matrix
## if double then return 2z|p
## otherwise return z|Div(p,2,N)
def XP2Zp(A,N,double=True):
    p = np.transpose([XPp(A)])
    z = XPz(A)
    if double:
        ## in this case, we double z component
        z = 2*z
    else:
        ## in this case, we halve p component
        if np.mod(N,2) == 0:
            ## easy if N is a multiple of 2
            p = p//2
        else:
            ## otherwise, use ring Div function
            p = vDiv(p,2,N)
    return np.hstack([z,p])

## return z and p components in single matrix
## if double then return 2z|p
## otherwise return z|Div(p,2,N)
def Zp2XP(A,N,double=True):
    n = np.shape(A)[-1]
    ## p is the last column
    p = np.take(A, n-1, -1)
    ## z is the rest of the matrix
    z = np.take(A, range(n-1), -1)
    ## X component - all zero, same shape as z
    x = ZMatZeros(np.shape(z))
    if double:
        ## we need to halve z
        if np.mod(N,2) == 0:
            z = z//2
        else:
            z = vDiv(z,2,N)
    else:
        ## we need to double p
        p = np.mod(p*2,2*N)
    return XPmergeComponents([p,x,z])

## Calculate residual of XP operator A of precision Nwith respect to Sz
def ZResidual(Sz,A,N):
    x = XPx(A)
    ## H is 2*z|p
    H = XP2Zp(Sz,N)
    zp = XP2Zp(A,N)
    ## residue of xp wrt H
    zp,a = matResidual(H,zp,2*N)
    ## convert back into XP operator
    A = Zp2XP(zp,N)
    ## get new p and z components
    p,x0,z = XPcomponents(A)
    return XPmergeComponents([p,x,z])

## perform operations represented by U on S
def doOperations(S,U,N):
    if len(S) == 0:
        return []
    temp = []
    m,n = getmn(U)
    n = XPn(S)
    for j in range(len(S),m):
        S.append(XPI(n))
    for j in range(len(U)):
        myrow = mat2list(U[j])
        op = GeneratorProduct(S,myrow,N)
        temp.append(op)
    return temp

## Prod(S[i]^u[i]) where S is a list of XP operators, u is a vector of integer
def GeneratorProduct(S,u,N):
    if len(S) == 0:
        return None
    n = XPn(S)
    u = np.mod(u,2*N)
    temp = XPI(n)
    for j in range(min(len(S),len(u))):
        uj = u[j]
        Sj = S[j]
        if uj >= 1:
            temp = XPMul(temp,XPPower(Sj,N,uj),N)
    return temp

## Canonical generators for set of XP operators G of precision N
def CanonicalGenerators(G,N,C=False):
    if C is not False:
        SC,SG = XPSpan(C,N),XPSpan(G,N)

        return XPEqual(SC,SG)
    ## Simplify X component
    S = simplifyX(G,N)
    ## Split into diag and non-diag operators
    Sx,Sz = splitDiag(S)
    ## Add squares and commutators of Sx
    toDo = [Sz]
    # print('Adding Squares and Commutators of Sx')
    for A in Sx:
        Sq = XPSquare(A,N)
        toDo.append(Sq)
        Comm = XPCommutator(A,Sx,N)
        toDo.append(Comm)
    Sz = np.vstack(toDo)
    ## Simplify Z component
    Sz = simplifyZ(Sz,N)

    ## Add commutators between Sx and Sz
    ## need to repeat t times
    t = max(0,logCeil(N-1,2))
    toDo = [Sz]
    for i in range(t-1):
        ## Commutators Level i+1
        for A in Sx:
            ## commutators between X operators and Z operators
            toDo.append(XPCommutator(A,Sz,N))
        Sz = np.vstack(toDo)
        ## Simplify Z component
        Sz = simplifyZ(Sz,N)

    toDo = []
    ## Simplify Z component of Sx
    for A in Sx:
        toDo.append(ZResidual(Sz,A,N))
    toDo.append(Sz)
    return np.vstack(toDo)

## check whether list of operators in canonical form S is admissible
## ie has any members with fundamental phase not equal to zero
def Admissible(S,N):
    f,d = XPFundamentalPhase(S,N)
    return np.all(f==0)


# def XOrbit(Sx,N,n):
#     opList, ixList = XOrbitBin(Sx,N,n)
#     order = weightOrder(ixList)
#     opList = [opList[i] for i in order]
#     return opList,ixList[order]

# def weightOrder(ixList):
#     wList = np.sum(ixList,axis=1)
#     return np.argsort(wList)

def OrbitOperator(Sx,N,n):
    Sindex, OSx = [[]],[XPI(n)]
    k = len(Sx)           
    for i in range(k):
        Sindex = [ix + [0] for ix in Sindex] + [ix + [1] for ix in Sindex]
        OSx = OSx + [XPMul(op,Sx[i],N) for op in OSx]
    return ZMat(OSx,2*n+1), ZMat(Sindex,k)

## main class for XP codes
class Code:

    ## set defaults for new code
    ## G is a list of XP operators
    ## N is the precision 
    def __init__(self,G,N):
        self.N = N
        self.n = XPn(G)
        self.G = G
    
    ## S is the canonical generators
    def getS(self):
        return(CanonicalGenerators(self.G,self.N))

    ## core Eq
    def getEq(self):
        Em = getVal(self,'Em')
        Eq,Lx = cosetDecomposition(Em)
        ## set value for Lx - X components of generating non-diagonal logicals
        setVal(self,'Lx',Lx)
        return Eq

    ## orbit representatives Em
    def getEm(self,check=False):
        N = self.N
        n = self.n
        S = getVal(self,'S')
        if not Admissible(S,N):
            print('Generators are not admissible')
            return None
        Sx,Sz = splitDiag(S)

        #### Calculate x: Set representing leading indices of X-component
        li = leadingIndices(XPx(Sx))
        report('li',li)

        ## array of Z and phase components
        Szp = XP2Zp(Sz,N,double=False)
        report('Szp')
        report(ZmatPrint(Szp,N))

        ##### Testing
        if check is not False:
            report('Checking Em')
            # report('Em',check)
            E = binSolveNaive(Szp,N,1,li)
            # report('solveNaive',E)
            return spaceSig(E) == spaceSig(check)

        # make NSpace modulo N from Szp
        nsp = NSpace(Szp,N)

        # make the kernel of A into a Howell basis
        nsp.simplifyKer()
        K = RemoveZeroRows(nsp.K[:,:-1])
        report('K')
        report(ZmatPrint(K,N))

        ###### Calculate the solution graph D by calling espaceSolve
        # D is the graph
        # (n,b) is the starting node for the solution
        D,(n,b) = espaceSolve(K,N,b=None,x=li)

        ###### convert graph D to a list L
        # L is a list of vectors c modulo N of length m
        # representing linear combinations of the rows of K
        A = graph2List(D,(n,b),rev=True)
        A = ZMat(A)
        report('A')
        report(ZmatPrint(A,N))

        ###### Convert L to list of binary vectors B - these are the solutions
        Em = ZMat([np.mod(a @ K, N) for a in A])
        return Em

        
    def getCodewords(self,check=False):
        if check is not False:
            return checkCodewords(check,self.G,self.N)
        N = self.N
        n = self.n
        S = getVal(self,'S')
        Sx,Sz = splitDiag(S)
        Em = getVal(self,'Em')
        p = ZMat([0]*len(Em))
        z = ZMatZeros(np.shape(Em))
        EmStates = XPmergeComponents([p,Em,z])
        OSx,Sindex = OrbitOperator(Sx,N,n)
        report('OSx')
        report(XP2Str(OSx,N))
        C = [XPMul(OSx,m,N) for m in EmStates] 
        setVal(self,'Sindex',Sindex)
        return C

#################
    
    def getLI(self,C=False):
        if C is not False:
            for op in C:
                
                result = self.testOperator(op)
                if result is False:
                    return False
                result = set(result)
                r = result.pop()
                # report(result)
                if r != (0,0) or len(result)>0:
                    return False
                # report(XP2Str(op,self.N),r)
            return True
        nspLI = getVal(self,'nspLI')
        SX,N = self.SX,self.N
        SX,SZ = LINew(SX,nspLI,N)
        # if not self.LI(C):
        #     report('LI ERROR')
        return SZ + SX

    def getindepVectors(self):
        core = getVal(self,'Eq')
        SXx, LXx= getVal(self,'SXx'),getVal(self,'LXx')
        # report('LXx',LXx)
        C = indepVectors(core,SXx,LXx,self.N)
        # report('check indepVectors', indepVectors(core,SXx,LXx,self.N,Check=C))
        return C

    def getnspLO(self):
        eList,SLCix,CWix = getVal(self,'indepVectors')
        return eList2nsp(eList,CWix,self.N)

    def getnspLI(self):
        eList,SLCix,CWix = getVal(self,'indepVectors')
        return eList2nsp(eList,np.ones((len(eList),1)),self.N)

    def getLO(self,C=False):
        N = self.N
        LI = getVal(self,'LI')
        if C is not False:
            # report('Logical Effect')
            # for A in C:
            #     Em,pList,Lix,Cix,CNo = getVal(self,'Em'),getVal(self,'pList'),getVal(self,'Lix'),getVal(self,'Cix'),getVal(self,'CNo')
            #     pDelta,eDelta = LENew(A,Em,pList,Lix,CNo,N)
            #     report(XP2Str(A,N),'Z',pDelta,'X',eDelta)
            # return True
            SX,SZ = getVal(self,'SX'),getVal(self,'SZ')
            for L in C:
                if not isLO(L,LI,self.N):
                    return False
            return True
                   

        eList,SLCix,CWix = getVal(self,'indepVectors')
        nspLO = getVal(self,'nspLO')
        LXx = getVal(self,'LXx')
        LX,LD = LONew(LXx,LI,N,eList,nspLO)
        setVal(self,'LX',LX)
        setVal(self,'LD',LD)
        self.updatemList()

        ## Remove phase component of X operators
        Em, pList = getVal(self,'Em'),getVal(self,'pList')
        LZH,H = LZSpace(LD,Em, pList,N)
        setVal(self,'LZH',LZH)
        # report('LZ',LZ)
        # report('H',H)
        for i in range(len(LX)):
            A = LX[i]
            b = LZEff(A,Em, pList,N)
            ## non-trivial LZ effect
            if not isZero(b):
                # report(XP2Str(A,N),b)
                b = np.mod(2*N-ZMat(b),2*N)
                ## offset LZ effect
                B = LZSpaceSolve(LZH,H,b,N)
                A = XPMul(A,B,N)
                LX[i] = A
        setVal(self,'LX',LX)
        LZ = []

        Lix = ZMat(self.Lix)
        for i in range(len(Lix[0])):
            # report('Lix',i)
            b = Lix[:,i] * N
            B = LZSpaceSolve(LZH,H,b,N)
            LZ.append(B)
        setVal(self,'LZ',LZ)
        return LD + LX

    def testOperator(self,op):
        Em = getVal(self,'Em')
        CW = getVal(self,'codeWords')
        muix = muIndex(Em)
        D = State2Dict((np.hstack([cw[0] for cw in CW]),np.vstack([cw[1] for cw in CW])))
        # report('D',D)
        SXx = [sx[1] for sx in self.S[0]]
        Action = []
        for pList,eList in CW:
            mu0,ix = matResidual(SXx,eList[0],2)
            mu0 = muix[tuple(mu0)]
            XAction = set()
            ZAction = set()
            for i in range(len(eList)):
                p0,e0 = pList[i],eList[i]
                p1,e1 = XPmulBasisElt(op,(p0,e0),self.N)
                mu1, ix = matResidual(SXx,e1,2)
                mu1 = muix[tuple(mu1)]
                XAction.add(mu1-mu0)
                pDelta = (p1 - D[tuple(e1)]) % (2*self.N)
                ZAction.add(pDelta)
            if len(XAction) > 1 or len(ZAction) > 1:
                report(XP2Str(op,self.N),'logical state',mu0,'Action',XAction,ZAction)
                return False
            Action.append((XAction.pop(),ZAction.pop()))
        return Action

    def getdimension(self):
        Em = getVal(self,'Em')
        return len(Em)

    def getdistance(self):
        LI = getVal(self,'LI')
        LO = getVal(self,'LO')
        LO2 = LOGroup(LO,LI,self.N)
        return minDistance(LO2)

    def updatemList(self):
        data = updatemList(getVal(self,'Eq'),getVal(self,'LX'),self.N)
        setVals(self,data)
    
    def __repr__(self):
        ## string representation of Code
        temp = []
        ## print the list of stabilizers
        for r in self.generators:
            temp.append(XP2Str(r,self.N))
        return "\n".join(temp)

    def __str__(self):
        return self.__repr__()


    def printCodewords(self,mode=2):
        C = getVal(self,'codeWords')
        N = self.N
        if mode == 2:
            sList = [[BasisElt2Str((c[0][j],c[1][j]),N) for j in range(len(c[0]))] for c in C]
        else:
            sList = [[a for a in c[mode]] for c in C]
        return self.LXSXCtable(sList)

    def getRegularSZ(self,Check=False):
        core, SX, LX = getVal(self,'Eq'), getVal(self,'SX'),getVal(self,'LX')
        return getRegularSZ(core, SX, LX,self.N)

    def LXSXCtable(self,data,tex=False):
        labels = ['Six','Lix','CNo','Sx','Lx']
        Six,Lix,CNo,Sx,Lx = getVals(self,labels)
        h1 =[""] * 2 + ['Sx'] + [arr2str(s) for s in Six]
        h2 = ['Lx','Eq','Bin'] + [arr2str(s) for s in Sx]
        headerRows =[h1,h2]
        dataRows = [[arr2str(Lix[i]),str(CNo[i]),arr2str(Lx[i])] + [str(c) for c in data[i]] for i in range(len(Lx))]
        dataRows = headerRows + dataRows
        # report(dataRows)
        m = len(dataRows)
        n = len(dataRows[0])
        colLen = [max([len(dataRows[i][j]) for i in range(m)]) for j in range(n)]
        dataRows = [[dataRows[i][j].rjust(colLen[j])  for j in range(n)] for i in range(m)]
        if tex:
            colsep = "&"
            rowsep = "\\\\\n"
        else:
            colsep = "| "
            o = 3
            for j in weightTransition(Six):
                for i in range(m):
                    dataRows[i][j+o] = colsep + dataRows[i][j+o]
            colsep = ' '
            rowSep = colsep.join(dataRows[0])
            pos = [i for i in range(len(rowSep)) if rowSep[i] == "|"]
            rowSep = ['-']*len(rowSep) + ["\n"]
            for i in pos:
                rowSep[i] = "|"
            rowSep = "".join(rowSep)
            o = 2
            for i in weightTransition(Lix):
                dataRows[i+o][0] = rowSep + dataRows[i+o][0]
            rowsep = "\n"
        dataRows = [colsep.join(r) for r in dataRows]
        dataRows = rowsep.join(dataRows)
        return dataRows

    
    ## measurement by codeword/operator method
    def measureCodewords(self,op):
        report(func_name(),XP2Str(op,self.N))
        cw = getVal(self,'codeWords')
        if len(cw) == 0:
            return False
        d = len(cw)
        r = len(cw[0][0])
        eList = np.vstack([c[1] for c in cw])
        pList = np.hstack([c[0] for c in cw])
        nList = np.hstack([[i for j in range(r)] for i in range(d)])
        # report('eList',eList)
        # report('pList',pList)
        # report('nList',nList)
        # evals = XPEigenvalues(op,self.N)
        N = self.N
        P = self.N * 2
        p,x,z = op
        report('z',z)

        ez = np.mod(np.inner(z, eList),P)
        if isZero(x):
            vList = np.mod(p + 2 * ez,P)
        else:
            ex = np.mod(x + eList,2)
            exz = np.mod(np.inner(z, ex),P)
            vList = np.mod(p + ez + exz,P)
            vListN = np.mod(vList + N,P)
            rList = np.mod(pList + ez - exz,P)
            rListN = np.mod(rList + N,P)
            eList = np.vstack([eList,ex,eList,ex])
            nList = np.hstack([nList,nList,nList,nList])
            vList = np.hstack([vList,vList,vListN,vListN])
            pList = np.hstack([pList,rList,pList,rListN])
        # report('evalList',evalList)
        outcomes, count = np.unique(vList, return_counts=True)
        # report(outcomes, count)
        m = len(vList)
        prob = {outcomes[i]: np.round(count[i]/m,2) for i in range(len(outcomes))}
        report = dict()
        for i in range(m):
            v = vList[i]
            if v not in report:
                report[v] = dict()
            n = nList[i]
            if n not in report[v]:
                report[v][n] = [],[]
            report[v][n][0].append(pList[i])
            report[v][n][1].append(eList[i])
        for v in report.keys():
            report(f'\np({v}/{N}) = {prob[v]}')
            report('Codewords')
            for n in report[v].keys():
                # report(State2Str(cw[n],P),'=>',State2Str(report[eval][n],P))
                c = StateSimplify(report[v][n],N) 
                report(State2Str(c,N))
            CW = list(report[v].values())
            # report('CW',CW)
            LI = LogicalI(CW,self.N)
            report('Maximal Stabilizers')
            op2 = op.copy()
            op2[0] = 0
            op2 = XPInverse(op2,N)
            if not LI:
                report("Could not calculate Logical I")
            else:
                for l in LI:
                    report(XP2Str(l,self.N),XP2Str(XPMul(l,op2,N), self.N))



    ## measurement by calculating projector of operator
    def measureProj(self,op):
        cw = getVal(self,'codeWords')
        cwC = [state2C(s,self.N) for s in cw]
        projList = matProjectors(op,self.N)
        for p, P in projList.items():
            report(f'\n{p}/{2*self.N}')
            for i in range(len(cw)):
                Pc = P @ cwC[i]
                prob = np.conjugate(cwC[i]) @ Pc
                prob = np.round(np.real(prob),2)
                prob = abs(prob)
                if prob > 0:
                    sP = C2state(Pc,self.N)
                    report(State2Str(sP,self.N*2))

    def measureQubit(self,a,xz):
        x = np.zeros(self.n,dtype=int)
        z = np.zeros(self.n,dtype=int)
        if xz==1:
            z[a] = self.N//2
            P = 2
        else:
            x[a] = 1
            P = self.N
        ## make an operator representing operator to measure
        A = [0,x,z]
        ## calculate residual
        ARes,ix = self.residual(A)
        p,d = XPFundamentalPhase(ARes,self.N)
        if d == 1:
            report('Deterministic')
            return p,None
        p = np.random.randint(2) * self.N
        A[0] = np.mod(-p,2*self.N)
        noncomm = []
        generators = [B.copy() for B in (self.S[0]+self.S[1])]
        for i in range(len(generators)):
            Bi = generators[i]
            ai = Bi[2-xz][a]
            bi = Bi[xz+1][a]
            # if ai > 0 and bi > 0:
            #     Bi = XPMul(A,Bi,self.N)
            #     generators[i] = Bi
            #     ai = Bi[2-xz][a]
            if ai > 0:
                noncomm.append((np.gcd(ai,P),bi,ai,i))
        toremove = []
        while len(noncomm):
            noncomm.sort(reverse=True)
            # report(noncomm)
            g0,b0,a0,i0 = noncomm.pop()
            B0 = generators[i0]
            toremove.append(i0)
            report('Removing Generator',XP2Str(B0,self.N))
            invalid = []
            for c in noncomm:
                (gi,bi,ai,i) = c
                if (b0 == 0 and gi % g0 == 0) or gi == g0:
                    Bi = generators[i]
                    if b0 == 0:
                        ## diagonal operator
                        u = Div(-ai,a0,P)
                    else:
                        ## non-diagonal operator
                        u = 1
                    # report('u,Bi',u,XP2Str(Bi,self.N))
                    Bj = XPMul(Bi,XPPower(B0,self.N,u),self.N)
                    ## Update the Generator
                    generators[i] = Bj
                    aj = Bj[2-xz][a]
                    bj = Bj[xz+1][a]
                    gj = np.gcd(aj,P)
                    ## update c
                    c = (gj,bj,aj,i)
                if c[2]> 0:
                    invalid.append(c)
            noncomm = invalid
        toremove.sort(reverse=True)
        for i in toremove:
            generators.pop(i)
        generators.append(A)
        return p,generators





def getRegularSZ(core, SX, LX,N,Check=False):
    q = core[0]
    # q = str2arr('0010001')
    n = len(q)
    SXx = ZMat([sx[1] for sx in SX],n)
    LXx = ZMat([sx[1] for sx in LX],n)
    if Check is not False:
        report('Checking',func_name())
        eList,SLCix,CWno = orbit2dist(core,SXx,LXx)
        for e in eList:
            for op in Check:
                (p,e) = XPmulBasisElt(op,(0,e),2)
                if p > 0:
                    return False
        return True

    # report(func_name(),'Eq')
    # report(mat2str(core))
    if len(core) != 1:
        return False
    

    nZero = np.zeros(n,dtype=int)

    ## Method 1
    nsp = NSpace(np.vstack([SXx,LXx]),2)
    nsp.simplifyKer()
    SZ = [XPRound([2*np.sum(q*k),nZero,k],2) for k in nsp.K]
    SZ = [XPSetN(sz,2,N) for sz in SZ]
    return SZ
        
    ## Method 2
    eList,SLCix,CWno = orbit2dist(ZMat([q]),SXx,LXx,1)
    A = np.hstack([eList,np.ones((len(eList),1),dtype=int)])
    nsp = NSpace(A,2)
    nsp.simplifyKer()

    SZ = [[-2*k[-1] % 4,nZero,k[:-1]] for k in nsp.K]
    SZ = [XPSetN(sz,2,N) for sz in SZ]

    report(func_name(),getRegularSZ(core, SX, LX,N,SZ))
    return SZ

def updatemList(core,LX,N):
    n = len(core[0])
    LXOrbit,LXix = XOrbit(LX,N,n)
    # report('LXix',LXix)
    idList = ['Lx','Cix','CNo','Lix','pList','Em']
    data={id:[] for id in idList}
    for lix in range(len(LXOrbit)):
        lx = LXOrbit[lix]
        for cix in range(len(core)):
            c = core[cix]               
            p,e = XPmulBasisElt(lx,(0,c),N)
            data['Em'].append(e)
            data['pList'].append(p)
            cRow = ZMat([0]*len(core))
            cRow[cix] = 1
            data['Cix'].append(cRow)
            data['CNo'].append(cix)
            data['Lix'].append(LXix[lix])
            data['Lx'].append(e)
    data={id:ZMat(val) for id,val in data.items()}
    return data


def LogicalI(codeWords,P,Check=False):
    if Check is not False:
        return checkCodewords(codeWords,Check,P)
    temp = []

    ## calculate Vx, Bx
    ## eList - basis elts in first codeword
    eList = codeWords[0][1]
    ## nZero - n zeros - for creating Z operators
    nZero = XPZeros(len(eList[0]))
    ## e0 - first basis elt in first codeword
    e0 = eList[0]
    ## add e0 to all elements of eList to get Vx
    Vx = np.mod(e0 + eList,2)
    # report(func_name())
    # report('E0',mat2str(Vx,"&"))
    nsp = NSpace(Vx,2)
    ## Bx - independent basis of Vx
    Bx = RemoveZeroRows(nsp.H)
    # report('Sx',mat2str(Bx,"&"))

    ## muList
    # muList = [matResidual(Bx,s[1][0],2)[0] for s in codeWords]
    # report('muList',muList)
    for s in codeWords:
        mu = tuple(matResidual(Bx,s[1][0],2)[0])
        # report('mu',mu)
        i = 0
        found = False
        while i < len(s[1]) and not found:
            if tuple(s[1][i]) == mu:
                found = True
            else:
                i+=1
        pmin = s[0][i]
        # report('pmin',pmin)
        if pmin > 0:
            s= (np.mod(s[0]-pmin,2*P),s[1])

    ## Generate Z Operators
    ## eList: basis elements for all codewords
    eList = np.vstack([s[1] for s in codeWords])
    col = np.ones((len(eList),1),dtype=int)
    ## add a column of all 1s to eList - represents operators with overall phase
    eList = np.hstack([eList,col])
    ## make an NSpace modulo P
    nsp = NSpace(eList, P)
    ## make an independent basis of Kernel
    nsp.simplifyKer()
    ## each k in K is a Z corresponds to a diagonal operator fixing eList
    # report('nsp.K',nsp.K)
    for k in nsp.K:
        p = k[-1]*2
        temp.append(XP2np([p,nZero,k[:-1]]))

    ## X operators
    ## pList: phases for all codewords
    pList = np.hstack([s[0] for s in codeWords])
    ## D is a dict of format {e:p}
    D = State2Dict((pList,eList))
    # report('D',D)    
    for x in Bx:
        if isZero(x):
            break
        ## append 0 to the end of the x vector
        x = np.hstack([x,[0]])
        # report('x',x)
        ## add x to all elements of eList
        ePlusx = np.mod(x + eList,2)
        ## StateDiff is D[e+x] - D[e]
        dp = StateDiff((pList,ePlusx),D,2*P)
        # report('dp',dp)

        ## dp mod 2 has to be 0 or 1 for all dp for there to be a valid solution
        dpmod2 = np.mod(dp,2)
        dpmax = max(dpmod2)
        if dpmax == 1:
            ## in this case, we need a factor of 1/2P for the operator
            ## we can only generate factors of 1/P using Z operators
            if min(dpmod2) == 0:
                ## if we have both 0 and 1, there is no solution
                report('Logical I - Invalid Phase dpmod2')
                return False
        ## subtract dpmax to dp is 0 mod 2, divide by 2 -> phases are modulo P
        dp = np.mod((dp - dpmax) // 2,P)
        k,d = nsp.makeOffset(dp)
        k = mat2list(k)
        # report('x',x)
        # report("p'''",dp)
        # report('b',k)
        if not(isZero(d)):
            ## cannot find a solution
            report('Logical I - Invalid Phase makeOffset')
            return False
        ## adjust the overall phase of the operator - adding back dpmax
        p = np.mod(k[-1]*2+dpmax,2*P)
        ## simplify operator
        op = XP2np([p,x[:-1],k[:-1]])
        # report('op',XP2Str(op,P))
        op,ix = XPResidual(temp,op,P,1)
        ## check degree > 1 and append the operator
        if XPDegree(op,P) > 1:
            temp.append(op)
    ## check the result
    # report('Checking LogicalI', LogicalI(codeWords,P,temp))
    return temp

def weightTransition(A):
    w = -1
    T = []
    for i in range(len(A)):
        wNew = np.sum(A[i])
        if w < wNew:
            T.append(i)
            w = wNew
    return T



def checkCodewords(codeWords,generators,N):
    # report('codeWords',codeWords)
    # report('generators',generators)
    # report('N',N)
    valid = True
    i = 0
    for b in codeWords:
        report('checking logical state',i)
        D = State2Dict(b)
        j = 0
        for g in generators:
            # report('checking generator',j)
            s = XPmulBasisElt(g,b,N)
            # report('checking',XP2Str(g,self.N),State2Str(b,self.N),State2Str(gb,self.N))
            C = StateDiff(s,D,2*N)
            # report('StateDiff',C)
            if not np.all(C==0):
                valid = False
                report("Failed: Codeword: ",i,"Generator: ",j)
                # report('b,s',State2Str(b,N*2),State2Str(s,N*2))
                report('delta',C)
            j += 1
        i+=1
    return valid

def RowSpan(A,N=2):
    A = ZMat(A)
    g = ZMat([np.lcm.reduce(N // np.gcd(a,N)) for a in A])
    # report('g',g)
    G = [range(a) for a in g]
    for ix in itertools.product(*G):
        # ix = list(ix)
        yield np.mod(ix @ A,N)

def SS2row(n,a):
    b = np.zeros(n,dtype=int)
    b[list(a)] = 1
    return b

def RowSpanComb(A,N=2,wMin=0,wMax=None,returnIx=False):
    A = ZMat(A)
    n = len(A)
    if wMax is None:
        wMax = n
    for m in range(wMin,wMax+1):
        for a in itertools.combinations(range(n),m):
            ix = SS2row(n,a)
            x= np.mod(ix @ A,N)
            if returnIx:
                yield x,ix
            else:
                yield x

def LOGroup(LO,LI,N):
    G = []
    for g in XPSpan(LO,N):
        if not XPisI(g):
            for h in XPSpan(LI, N):
                g = XPMul(g,h,N)
                R,ix = XPResidual(LI,g,N)
                if XPDegree(R,N)>1:
                    G.append(g)
    return G

def minDistance(G):
    D = [XPdistance(op) for op in G]
    return min(D)

def getT(Em):
    m0 = Em[0]
    n = len(m0)
    Em = ZMat(Em,n)
    EmSet = {tuple(m) for m in Em}
    Em0 = [np.mod(m - m0,2) for m in Em[1:]]
    T = []
    for x in Em0:
        Emx = np.mod(Em + x,2)
        if np.all([tuple(m) in EmSet for m in Emx]):
            T.append(x)
    return ZMat(T,n)
       
def cosetDecomposition(Em):
    Em = ZMat(Em)
    n = len(Em[0])
    ## get valid transitions
    Lx = getT(Em)
    report('T')
    report(ZmatPrint(Lx,2))
    ## get RREF of T
    if len(Lx) > 0:
        Xnsp = NSpace(Lx,2)
        Lx = RemoveZeroRows(Xnsp.H)
        Eq = set()
        for m in Em:
            q,u = matResidual(Lx,m,2)
            Eq.add(tuple(q))
        Eq = ZMat(sorted(Eq),n)
    else:
        Eq = Em
    report('Lx is RREF(T)')
    report(ZmatPrint(Lx,2))
    return Eq,Lx  

def coreLE(Em,N):
    XList = getT(Em,N)
    if len(XList) > 0:
        Xnsp = NSpace(XList,2)
        XList = RemoveZeroRows(Xnsp.H)
    core = {}
    mix = []
    for m in Em:
        b,ix = matResidual(XList,m,2)
        b = tuple(mat2list(b))
        ix = tuple(mat2list(ix))
        if b not in core:
            core[b] = len(core)
        mix.append((ix,core[b]))
    C = [0]*len(core)
    for c,i in core.items():
        C[i] = list(c)
    core = ZMat(C)
    return XList,core 


def LXNew(Em,xList,eList,XBasis,nsp,P,d=None):
    # D = phaseDict(Em,XBasis,P)
    # D = phaseDict2(Em,XBasis,xList,P)
    D = phaseDict3(eList,XBasis,xList,P)
    # report('D')
    # for k,v in D.items():
    #     report(k,'=>',v)
    n = len(eList[0])
    # report('xList',xList)
    # report('D',D)    
    temp = []
    muSet = {tuple(m) for m in Em}
    for x in xList:
        ## check if x is a valid transition within Em
        mux = [tuple(np.mod(m +x,2)) for m in muSet]
        if np.all([m in muSet for m in mux]):
            # report('x',x)
            ## add x to all elements of eList
            ## StateDiff is D[e+x] - D[e]

            dp = np.mod([D[tuple(np.mod(x+e,2))] - D[tuple(e)] for e in eList],2*P)
            # report('dp',dp)

            ## dp mod 2 has to be 0 or 1 for all dp for there to be a valid solution
            dpmod2 = np.mod(dp,2)
            # report('dpmod2',dpmod2)
            dpmax = max(dpmod2)
            if dpmax == 1:
                ## in this case, we need a factor of 1/2P for the operator
                ## we can only generate factors of 1/P using Z operators
                if min(dpmod2) == 0:
                    ## if we have both 0 and 1, there is no solution
                    report('Logical Operator - Invalid Phase')
                    # return False
            ## subtract dpmax to dp is 0 mod 2, divide by 2 -> phases are modulo P
            dp = np.mod((dp - dpmax) // 2,P)
            k,o = nsp.makeOffset(dp)
            # k = mat2list(k)
            if not(isZero(o)):
                ## cannot find a solution
                report('Logical Operator - Invalid Phase')
                # return False
            else:
                ## adjust the overall phase of the operator - adding back dpmax
                p = dpmax
                LX = XP2np([p,x,k[:n]])
                ## check if LX meets min distance requirement
                if d is not None and XPdistance(LX) < d:
                    # report("LX",XP2Str(LX,P))
                    return False
                ## append the x operator
                temp.append(LX)
    ## check the result
    # report('Checking LogicalI', LogicalI(codeWords,P,temp))
    return temp   

def LINew(SX,nspLI,N):
    n = nspLI.n-1
    nZero = XPZeros(n)
    SZ = []
    # report(func_name(),'K')
    # report(nspLI.K)
    for k in nspLI.K:
        z = k[:n]
        p = (2*k[n]) % (2*N)
        SZ.append([p,nZero,z])
    temp = []
    for lo in SX:
        op,ix = XPResidual(SZ,lo,N,1)
        temp.append(op)
    SX = temp
    return SX,SZ   

def LZSpace(LO,Em,pList,N):
    n = len(Em[0])
    LZ = [A for A in LO if XPisDiag(A)]
    wI = XPI(n)
    wI[0] = 1
    LZ.append(wI)
    LE = [LZEff(A,Em,pList,N) for A in LZ]

    nsp = NSpace(LE,2*N)
    nsp.getVal('P')
    nsp.simplifyH()
    U = nsp.P
    LZ = doOperations(LZ,U,N)
    # report(func_name(),'H')
    # report(mat2str(nsp.H))
    # report('LZ')
    # report(XPList2Str(LZ,N))
    return LZ,nsp.H

def LZSpaceSolve(LZ,H,b,N):
    # report(func_name(),b)
    o,u = matResidual(H,b,2*N)
    # if not isZero(o):
        # report(func_name(),'Could not solve. Offset',o)
    A = GeneratorProduct(LZ,u,N)
    return A

def LZEff(A,eList,pList,N):
    D = {tuple(eList[i]):i for i in range(len(eList))}
    # report(func_name())
    # report('eList')
    # report(mat2str(eList))
    # report('pList')
    # report(pList)
    # report('A',A)
    pNew,eNew = XPmulBasisElt(A,(pList,eList),N)
    delta = []
    for i in range(len(eNew)):
        e,p = eNew[i],pNew[i]
        etup = tuple(e)
        if etup not in D:
            report(func_name(),' error - invalid transition')
        j = D[etup]
        delta.append((p-pList[j]) % (2*N))
    return delta

def LENew(A,eList,pList,Lix,CNo,N):
    n = len(eList[0])
    LNo = [row2int(l) for l in Lix]
    LMax = max(LNo) + 1
    CMax = max(CNo) + 1
    d = int(max(LNo)).bit_length()

    D = {tuple(eList[i]):i for i in range(len(eList))}
    pNew,eNew = XPmulBasisElt(A,(pList,eList),N)
    delta = [[],[]]
    CN = max(set(CNo)) + 1

    for i in range(len(eNew)):
        e,p = eNew[i],pNew[i]
        etup = tuple(e)
        if etup not in D:
            report(func_name(),' error - invalid transition')
        j = D[etup]
        delta[0].append((p-pList[j]) % (2*N))
        delta[1].append(tuple(np.mod(Lix[i]+Lix[j],2)))
    temp = []
    for j in range(2):
        # pGlobal = min([(-delta[i].count(p),p) for p in set(delta[i])])
        # pGlobal = pGlobal[1]
        # deltap = np.mod(deltap - pGlobal,2*N)
        PE = dict()
        deltap = delta[j]
        for i in range(len(deltap)):
            p = deltap[i]
            # ix = tuple(Lix[i])+tuple([CNo[i]])
            if p not in PE:
                PE[p] = []
            PE[p].append(i)
        for p,E in PE.items():
            A = ZMat([[LNo[i],CNo[i]] for i in E])
            B,g = LECore(A,[LMax,CMax])
            # report('B',B)
            # report('g',g)
            PE[p] = [list(int2row(b[0],2,d)) + [(b[1])] for b in B]
        temp.append(PE)
    return temp

def LECore(A,N):
    Atup = {tuple(a) for a in A}
    # report('A')
    # report(mat2str(A))
    delta = np.mod(A -A[0],N)
    # report('delta')
    # report(mat2str(delta))
    trans = []
    for d in delta:
        valid = True
        for a in A:
            if tuple(np.mod(a + d,N)) not in Atup:
                valid = False
                break
        if valid:
            trans.append(d)
    trans = ZMat(trans)
    # report('trans')
    # report(trans)
    B = []
    while len(Atup) > 0:
        b = min(Atup)
        B.append(b)
        # Atup.remove(b)
        b = ZMat(b)
        for t in trans:
            b1 = tuple(np.mod(t + b,N))
            Atup.remove(b1)
    return B,trans


def isLO(L,LI,N):
    for A in LI:
        C = XPCommutator(A,L,N)
        # report(XP2Str(C,N))
        R,u = XPResidual(LI,C,N,1)
        # report(XP2Str(R,N)) 
        if not XPisI(R):
            report(func_name(),XP2Str(L,N),XP2Str(A,N),XP2Str(C,N),XP2Str(R,N))
            return False
    return True

def LONew(LXx,LI,N,eList,nsp):
    SX = []
    SZ = []
    for op in LI:
        B = SZ if XPisDiag(op) else SX
        B.append(op)

    n = len(eList[0])
    nZero = XPZeros(n)

    LZ = []
    LIz = [op[2] for op in LI if XPisDiag(op)]
    # report(func_name(), 'K')
    # report(nsp.K)
    for k in nsp.K:
        z = k[:n]
        z,ix = matResidual(LIz,z,N)
        LZ.append(z)
    
    ## not sure if this is necessary...
    Znsp = NSpace(LZ,N)
    LZ = RemoveZeroRows(Znsp.H)
    LZ = ZMat(LZ,n)
    
    LD = np.vstack([LIz,LZ])
    nspD = NSpace(LD,N)
    nspD.simplifyH()
    LD = nspD.H

    # report(func_name(),LZ,LZ.shape)
    LZ = [[0,nZero,z] for z in LZ]


    LX = []
    if len(LXx) > 0:
        D = phaseDict3(eList,SX,LXx,N)
        for x in LXx:
            result = GetLX(x,D,eList,nsp,N)

            if result is not False:
                lo,b = result
                res = fixSquare(lo[1],lo[2],LD,N)
                if res is not None:
                    lo = res
                else:
                    lo[2],ix = matResidual(LIz,lo[2],N)
                    
                    # report(XP2Str(lo,N),"=>",XP2Str(op,N))
                    ## try to make X^2 = I in logical terms
                    L2 = XPSquare(lo,N)
                    report('L2',XP2Str(L2,N))
                    L2,u = XPResidual(LI,L2,N,1)
                    # lo[0] = (-L2[0]//2) % (2*N)
                    report('L2',XP2Str(L2,N))
                    B = XPRound([-c//2 for c in L2],N)
                    # report('B',XP2Str(B,N))
                    ## check if B is in LZ group
                    B2,u = XPResidual(LZ,B,N,1)
                    if sum(B2[2]) == 0:
                        lo = XPMul(lo,B,N)
                    else:
                        lo[0] = B[0]
            LX.append(lo)
    return LX,LZ

def fixSquare(x,z,LD,N):
    report(func_name())
    x1 = np.mod(x+1,2)
    xz = np.mod(2*x1*z,N)
    report('xz',xz)
    report('LD')
    report(LD)
    xLD = np.mod(2*x1*LD,N)
    report('xLD')
    report(xLD)
    b,u = matResidue(xLD,xz,N)
    report('b,u',b,u)
    if isZero(b):
        z1 = matMul(u,LD,N)
        report('z1',z1)
        z1 = z1[0]
        n = len(z1)
        A = XPRound([0,XPZeros(n),z + z1],N)
        
        A[1] = x
        report('A',XP2Str(A,N))
        A2 = XPSquare(A,N)
        A[0] = np.mod(-A2[0]//2,2*N)
        A2 = XPSquare(A,N)
        report('A2',XP2Str(A2,N))
        return A
    return None
    

## phase dictionary for calculation of Logical X
def phaseDict3(eList,XBasis,xList,P):
    SXx = [op[1] for op in XBasis]
    temp = dict()
    n = len(eList[0])
    for i in range(len(eList)):
        ei = eList[i]
        mu,ix = matResidual(SXx,np.mod(ei,2),2)
        # ix = mat2list(ix)
        op = GeneratorProduct(XBasis,ix,P) 
        if op is None:
            op = XPI(n)
        p,e = XPmulBasisElt(op,(0,mu),P)
        temp[tuple(e)] = p
        for x in xList:
            mux = np.mod(mu+x,2)
            p,e = XPmulBasisElt(op,(0,mux),P)
            temp[tuple(e)] = p
    return temp

def GetLX(x,D,eList,nsp,N):
    # report(func_name(),'x',x)
    n = len(eList[0])
    dp = np.mod([D[tuple(np.mod(x+e,2))] - D[tuple(e)] for e in eList],2*N)
    # report('dp',dp)
    a = set(np.mod(dp,2))
    if len(a) > 1:
        report(func_name(),'invalid a')
        return False
    a = a.pop()
    dp = (dp - a) // 2
    # report('dp',dp)
    k,o = nsp.makeOffset(dp)
    # 
    # report('a',a)
    # report('k',k)
    if not(isZero(o)):
        ## cannot find a solution
        report(func_name(),'Invalid Phase')
        return False
    ## adjust the overall phase of the operator - adding back a
    op = XP2np([a,x,k[:n]])
    return op,k[n:]

def leadingIndex(a):
    # report('a',a)
    i = 0
    n = len(a)
    while i < n and a[i]==0:
        i+=1
    return i

def orbit2dist(core,SXx,LXx,w=None):
    d = len(LXx[0]) if len(LXx) > 0 else 0
    n = len(core[0])
    # report(func_name(),'SXx',SXx)
    # report('LXx',LXx)
    Xx = np.vstack([SXx,LXx])
    # report(func_name(),'Xx')
    # report(mat2str(Xx))
    if w is None:
        w = len(Xx)
    # if len(Xx) == 0:
    #     Xx = np.zeros(n,dtype=int)
    A = []
    col = []
    CWno = []
    # report('Eq')
    # report(mat2str(core))
    coreix = ZMat(list(range(len(core))))
    Ic = np.eye(len(core),dtype=int)
    for x,ix in RowSpanComb(Xx,wMax=w,returnIx=True):
        A.append(np.mod(core + x,2))
        col.append(np.hstack([[ix]*len(core),Ic]))
        cw = row2int(ix[len(SXx):]) * len(core)
        # report('cw',cw)
        # report('ix[len(SXx):]',ix[len(SXx):])
        CWno.append(cw + coreix)
    return np.vstack(A),np.vstack(col),np.hstack(CWno)

## make a column out of a list of codeword numbers
def CWcol(CWno):
    CWix = sorted(set(CWno))
    CWix = {CWix[i]:i for i in range(len(CWix))}
    ## format of col: SXIndex|LXIndex|coreIndex
    temp = np.zeros((len(CWno),len(CWix)),dtype=int)
    for i in range(len(CWno)):
        temp[i,CWix[CWno[i]]] = 1
    return temp

def indepVectors(core,SXx,LXx,N,w=None,OrbType=1,Check=False):
    ## todo - write in terms of SX,LX,Core
    if Check is not False:
        eListAll,SLCix,CWix = indepVectors(core,SXx,LXx,N,w=len(SXx)+len(LXx))
        # report('eListAll')
        # report(mat2str(eListAll))
        # report(mat2str(col))
        eList,SLCix,CWix = Check

        # report('eList')
        # report(mat2str(eList))
        # report(mat2str(col))
        return len(eList) == len(eListAll)
    n = len(core[0])
    c = len(core)
    if w is None:
        ## default to the depth of N ie max(t) where N = 2^t * m
        w = NDepth(N)

    if OrbType==0:
        ## orbit from core
        eList,SLCix,CWno = orbit2dist(core,SXx,LXx,w)
        CWix = np.ones((len(eList),1),dtype=int)
    else:
        ## orbit from Em
        nRow = ZMat([],n)
        Em,SLCix,CWno = orbit2dist(core,nRow,LXx)
        eList,SLCix,CWno = orbit2dist(Em,SXx,nRow,w)
        CWix = CWcol(CWno)

    # report('SLCix')
    # report(mat2str(SLCix))   
    # report('CWno')
    # report(CWno)
    
    # report('CWix')
    # report(mat2str(CWix))    
    A = np.hstack([eList,CWix])
    # report(func_name(),'len(A)',len(A))
    # A = ZMat(A)
    # report('A')
    # report(mat2str(A))
    ix = HowellIncremental(A,N)
    eList,SLCix,CWno = eList[ix],SLCix[ix],CWno[ix]
    CWix = CWcol(CWno)
    # report('eList')
    # report(mat2str(eList))
    C = eList,SLCix,CWix 
    
    return C

def eList2nsp(eList,col,N):
    nspLO = NSpace(np.hstack([eList,col]),N)
    nspLO.simplifyKer()
    return nspLO

#################################        
##   Simultaneous Eigenspaces  ##
#################################  

## hashable signature of eigenspace
def spaceSig(L):
    temp = [tuple(l) for l in L]
    return tuple(sorted(temp))

## text version of eigenspace
def spaceTxt(L):
    T = ["".join(map(str,x)) for x in L]
    return "\\".join(T)+ "\\"

## solve for Ae = p
# A is m x n matrix modulo N
# p is a length m string modulo N representing phases
# x is a list of indices 0 <= i < n where we require e[i] = 0
# output [e] are is a length n binary string
def binSolve(A,N,p=None,x=None,check = False):
    # no rows in A, return empty list
    if len(A) == 0:
        return []
    # default for p vector
    if p is None:
        p = [0] * len(A)
    # default for x vector
    if x is None:
        x = []
    x = set(x)
    # make NSpace modulo N from A
    nsp = NSpace(A,N)
    # make an offset b - solutions modulo N are in the format
    # x = b + k where k in Ker(A)
    b,o = nsp.makeOffset(p)

    # if o[c] > 0 for some c, then there is no solution
    if not isZero(o,N):
        return []
    # convert b to list format
    b = mat2list(b)
    # make the kernel of A into a Howell basis
    nsp.simplifyKer()
    K = nsp.K
    b,ix = matResidual(K,b,N)
    # check is for testing
    if check is not False:
        report('Checking binSolve')
        report('binSolve',check)
        E = binSolveNaive(A,N,p,x)
        report('solveNaive',E)
        return spaceSig(E) == spaceSig(check)
    # call espaceSolve
    # D is the graph
    # (n,b) is the starting node for the solution
    D,(n,b) = espaceSolve(K,N,b=b,x=x)
    # convert graph D to a list L
    L = graph2List(D,(n,b),rev=True)
    L = ZMat(L)
    # report('L',L)
    # L is a list of vectors c modulo N of length m
    # representing linear combinations of the rows of K
    # Convert these to binary vectors B
    if len(L):
        B = [np.mod(a @ K + b, N) for a in L]
    else:
        B = []
        if np.all([i < 2 for i in b]):
            B.append(b)
    return ZMat(B)

# ## Incremenet binary row
def binRowInc(val):
    carry = 1
    i = len(val) - 1
    while carry > 0 and i > -1:
        if val[i] == 1:
            val[i] = 0
        else:
            val[i] = 1
            carry = 0
        i = i -1
    return val

def binSpliceZeros(val,x):
    ## splice zeros into positions indicated by x
    temp = []
    ## i is the counter for position in val
    i = 0
    ## j is the counter for position in temp
    for j in range(len(val) + len(x)):
        ## if j in x, we need to have a zero in this position
        if j in x:
            temp.append(0)
        else:
            ## check if i is a valid counter for val
            if i < len(val):
                temp.append(val[i])
                i+=1
    return temp

# solve for Ax = p in binary strings
# positions indicated by x are zero
def binSolveNaive(A,N,p,x):
    temp = []
    m = len(A)
    if m == 0:
        ## nothing to check - return empty array
        return temp
    if p is None:
        ## phase to solve for p = 1 by default
        p = [0]* m
    ## ensure 0 <= p < N
    p = np.mod(p,N)
    ## make sure that all entries in x are valid
    x = [i for i in x if i < len(A[0])]
    ## all entries in x are zero, so fewer options to check
    n = len(A[0]) - len(x)
    ## initial value of e - 0
    e = [0] * n
    for k in range(1 << n):
        ## splice zeros into positions indicated by x
        ex = binSpliceZeros(e,x)
        ex = ZMat(ex)
        r = 0
        valid = True
        ## check phase for each row of A
        while r < len(A) and valid:
            ## multiply ex by A[r], modulo N
            if np.sum(ex * A[r]) % N != p[r]:
                valid = False
            r += 1
        if valid:
            temp.append(ex)
        ## next value of e
        e = binRowInc(e)
    return ZMat(temp)

## generic graph to list
def graph2List(D,ix=None,rev=False,s=tuple()):
    if ix is None:
        ix = max(D.keys())
    temp = []
    (n,p) = ix
    if ix in D:
        if len(D[ix]):
            for d,p1 in D[ix].items():
                s1 = s+(d,) if rev else (d,)+s
                n1 = n+1 if rev else n-1
                if p1 is not None:
                    temp += graph2List(D,(n1,p1),rev,s1)
                else:
                    temp.append(s1)
    return temp

## print generic graph
def printGraph(D):
    nodeCount = dict()
    # KList = sorted(D.keys(),reverse=True)
    KList = D.keys()
    for k in KList:
        L = len(D[k])
        # if L > 0:
            # report(k,D[k])
        if L not in nodeCount:
            nodeCount[L] = 1
        else:
            nodeCount[L] += 1
    m = max(nodeCount.keys())+1
    nodeCount = [nodeCount[i] if i in nodeCount else 0 for i in range(m)]
    report('nodeCount',nodeCount)
    report('total Nodes',sum(nodeCount))

def leadingIndices(K):
    n = len(K)
    if n == 0:
        return []
    L = [len(K[0])] * (n)
    m = len(K[0])
    i = 0
    j = 0
    while i < m and j < n:
        if K[j][i] == 0:
            i += 1
        else:
            L[j] = i
            j+=1
            # i+=1
    return L

# zeroCols[r] = [c] where K[r][c] = 0 for all r
def zeroCols(K):
    m = len(K)
    if m ==0:
        # no rows, return empty list
        return []
    # length of first row of K
    n = len(K[0])
    # colSetRows[c] = [r] such that K[r][c] > 0
    colSetRows = [[r for r in range(m) if K[r][c] > 0] for c in range(n)]
    return [c for c in range(n) if len(colSetRows[c]) == 0]

# lowestCols[r] = [c] where K[r][c] > 0 and K[s][c] = 0 for all s > r
# If binarising, when we get to row r of K, b[c] must all be 0 or 1 
# as this is the last row where the b[c] can change
def lowestCols(K):
    m = len(K)
    if m ==0:
        # no rows, return empty list
        return []
    # length of first row of K
    n = len(K[0])
    # colSetRows[c] = [r] such that K[r][c] > 0
    colSetRows = [[r for r in range(m) if K[r][c] > 0] for c in range(n)]
    # temp is a vector of length m = len(K)
    temp = [[] for r in range(m)]
    for c in range(n):
        # check if there are any rows r where K[r][c] > 0
        if len(colSetRows[c]) > 0:
            # r is the largest such that K[r][c] > 0
            r = max(colSetRows[c])
            # append c to the list for row r
            temp[r].append(c)
    return temp

# Solve for e = b + cK for vector c such that:
# 0 <= c[i] < N, 0 <= i < len(K)
# e a binary vector, e[x] = 0
def espaceSolve(K,N,b=None,x=None):
    K = ZMat(K)
    # report('K')
    # report(K)
    # set defaults for vector x
    if x is None:
        x = []    
    x = set(x)
    # set defaults for vector b
    if b is None:
        m = 0 if len(K) == 0 else len(K[0])
        b = [0]*m
    # starting node = ix
    # starting row of K=0
    # residual vector=b 
    ix = (0,tuple(b))
    # initialize graph
    D = dict()

    # get lowestCols of K
    LC = lowestCols(K)
    # call recursive function espaceGraph
    temp = espaceGraph(K,N,x,ix,D,LC)
    # return the graph D and starting node ix
    return D,ix
		
## graph solution of eigenspace of operator list K
def espaceGraph(K,N,x,ix,D,LC):
    if ix in D:
        return D[ix]
    temp = dict()
    # r: row number of K
    # b0: residual vector we are seeking to binarise
    r,b0 = ix
    # L: lowestCols; Lr = lowestCols[r]
    Lr = LC[r]
    # l: index of leading nonzero entry of K[r]
    li = Lr[0]
    # p: corresponding entry in b0 - needs to be 0 or 1
    p = b0[li]
    # k: corresponding entry in K[r]
    k = K[r][li]
    # cList: possible values c such that p + k * c = 0/1 mod N
    aList = []

    if p % k  == 0:
        # in this case, we can make p + k * c = 0
        a = ((N-p)//k) % N
        aList.append(a)
    if li not in x and (p-1) % k == 0:
        # in this case, we can make p + k * c = 1
        # if l in x, then only 0 is allowed
        a = ((N+1-p)//k) % N
        aList.append(a)
    if len(aList):
        b0 = ZMat(b0)
        PSet = {}
        for a in aList:
            # b1 is b0 + c * K[r]
            b1 = np.mod(b0 + a * K[r],N)
            # b1[l] = 0
            valid = True 
            i = 1
            while valid and i < len(Lr):
                j = Lr[i]
                valid = b1[j] < 1 if j in x else b1[j] < 2
                # if j in x, then only 0 is allowed for b1[j]
                # otherwise, either 0 or 1 is allowed
                # b1[j] = 0
                i += 1
            if valid:
                # set b1 corresponding to Lr to zero - these are all 0 or 1
                b1[Lr] = 0
                PSet[a] = tuple(b1)
        if r == len(K) - 1:
            # in this case, we are at the last row of K
            for a,b1 in PSet.items():
                # base case - no recursion required
                temp[a] = None
        else:
            for a,b1 in PSet.items():
                # recursion - s = solutions for r+1, for vector b1
                s = espaceGraph(K,N,x,(r+1,b1),D,LC)
                if len(s):
                    # if there are valid solutions, create a link in the node
                    temp[a] = b1
    # update the solutions graph
    D[ix] = temp
    return temp 


# ## Code 1
# genstr = 'XP_8(8|0000000|6554444),XP_8(7|1111111|1241234),XP_8(1|1110000|3134444)'

# ## Code 1 test
# # genstr = 'XP8(8|0000000|2334444),XP8(0|0000000|0440000),XP8(9|1110000|1240000),XP8(14|0001111|0001234)'

# ## Code 2
# # genstr = 'XP8(0|0000000|1322224)\nXP8(12|1111111|1234567)'

# G, N = str2XP(genstr)
# print('Generators')
# print(XP2Str(G,N))

# C = Code(G,N)
# S = getVal(C,'S')
# print('CanonicalGenerators')
# print(XP2Str(S,N))
# print('Checking CanonicalGenerators:',CanonicalGenerators(G,N,S))
# print('Admissible',Admissible(S,N))

# Em = getVal(C,'Em')
# print('Em')
# print(ZmatPrint(Em,2))

# Eq = getVal(C,'Eq')
# print('Eq')
# print(ZmatPrint(Eq,2))

# print('Codewords')
# CW = getVal(C,'Codewords')
# for c in CW:
#     print(State2Str(c,N))

