import numpy as np
from common import *
from NSpace import *
from XPAlgebra import *
import itertools

## XP group generated by set of XP operators S of precision N
## doesn't factor in order of operators...
def XPSpan(S,N):
    S = ZMat2D(S)
    # S = ZMatSort(S)
    # ## G is the group generated
    # G = []
    ## U - set to avoid duplications in G
    U = set()
    ## Maxpowers: m such that A^m = I
    f,d = XPFundamentalPhase(S,N)
    A = np.gcd(f,2*N)
    # print('f,d,A',f,d,A)
    maxPowers = d * 2*N // A
    # report('maxPowers',maxPowers)
    Sm = XPPower(S,N,maxPowers)
    # report('Sm')
    # report(XP2Str(Sm,N))
    ## convert into range for itertools
    maxPowers = [range(a) for a in maxPowers]
    # print('maxPowers',maxPowers)
    for u in itertools.product(*maxPowers):
        # g = None
        # for i in range(len(maxPowers)):
        #     h = XPPower(S[i],N,t[i])
        #     g = h if g is None else XPMul(g,h,N)
        A = GeneratorProduct(S,u,N)
        # strA = XP2Str(A,N)
        strA = tuple(A)
        if strA not in U:
            # G.append(g)
            U.add(strA)
            yield A
    # return ZMat2D(G)

## split XP operators into non-diagonal and diagonal operators
def splitDiag(G):
    G = ZMat2D(G)
    S = [[],[]]
    n = XPn(G)
    for g in G:
        i = 1 if XPisDiag(g) else 0
        S[i].append(g)
    if len(S[1]) == 0:
        S[1].append(XPI(n))
    return [ZMat(S[i],2*n+1) for i in range(2)]

## Simplify X components of XP operators G of precision N
def simplifyX(G,N,C=False):
    if C is not False:
        print('Testing',func_name())
        return testGroup(G,N,C)
    n = XPn(G)
    ## split into diagonal and non-diagonal operators
    SX,SZ = splitDiag(G)
    ## make RREF of X-components
    SXx = XPx(SX)
    nsp = NSpace(SXx,2)
    ## P represents transformation to Howell basis
    U = nsp.getVal('P')
    ## corresponding group operations on SX
    SXnew = doOperations(SX,U,N)
    ## Kt represents transformations of SXx resulting in zero rows 
    U = nsp.getVal('Kt')
    ## corresponding operators are diagonal, may be trivial
    SZnew = doOperations(SX,U,N)
    SZnew = RemoveZeroRows(SZnew)
    SZ = np.vstack([SZ,SZnew])
    SZ = simplifyZ(SZ,N)
    ## return both updated SX and SZ
    return np.vstack([SXnew,SZ])

## simplify Z components of SZ
def simplifyZ(SZ,N):
    # # report(func_name())
    SZ = RemoveZeroRows(SZ)
    ## A is 2*z|p
    SZzp = XP2Zp(SZ,N)

    # # report('SZzp')
    # # report(ZMat2str(SZzp,2*N))
    # ## get Howell basis
    nsp = NSpace(SZzp,2 * N)
    # nsp.simplifyH()
    How_SZzp = nsp.H
    ## this step is not required as Z components are always multiples of 2
    # How_SZzp = ensure2Z(nsp.H,N) 

    # # report('How_2N(S_Zp)')
    # # report(ZMat2str(How_SZzp,2*N))
    ## convert back to operators
    SZ = Zp2XP(How_SZzp,N)
    return SZ

## ensure that the Z component is a multiple of 2
def ensure2Z(SZzp,N):
    # report(func_name(),'SZzp before')
    # report(ZmatPrint(SZzp,2*N))
    n = np.shape(SZzp)[-1]-1
    s = [2]*n + [1]
    I2 = np.diag(s)
    SZzp = nsIntersection([I2,SZzp],2*N)
    # report(func_name(),'SZzp after')
    # report(ZmatPrint(SZzp,2*N))
    return SZzp

## Simplify Z component of SX
def simplifyXZ(SX,SZ,N):
    n = max(np.shape(SX)[-1],np.shape(SZ)[-1])
    SX = ZMat([ZResidual(SZ,z,N)[0] for z in SX],n)
    return SX

## vectorized version of Div
vDiv = np.vectorize(Div)
    
## return z and p components in single matrix
## if double then return 2z|p
## otherwise return z|Div(p,2,N)
def XP2Zp(A,N,double=True):
    p = np.transpose([XPp(A)])
    z = XPz(A)
    if double:
        ## in this case, we double z component
        z = 2*z
    else:
        ## in this case, we halve p component
        if np.mod(N,2) == 0:
            ## easy if N is a multiple of 2
            p = p//2
        else:
            ## otherwise, use ring Div function
            p = vDiv(p,2,N)
    return np.hstack([z,p])

## return z and p components in single matrix
## if double then return 2z|p
## otherwise return z|Div(p,2,N)
def Zp2XP(A,N,double=True):
    n = np.shape(A)[-1]
    ## p is the last column
    p = np.take(A, n-1, -1)
    ## z is the rest of the matrix
    z = np.take(A, range(n-1), -1)
    ## X component - all zero, same shape as z
    x = ZMatZeros(np.shape(z))
    if double:
        ## we need to halve z
        if np.mod(N,2) == 0:
            z = z//2
        else:
            z = vDiv(z,2,N)
    else:
        ## we need to double p
        p = np.mod(p*2,2*N)
    return makeXP(p,x,z)

## Operator Residue of A wrt diagonal canonical generators SZ
def ZResidual(SZ,A,N):
    if np.size(SZ) == 0:
        return A,ZMat([])
    x = XPx(A)
    ## H is 2*z|p
    H = XP2Zp(SZ,N)
    zp = XP2Zp(A,N)
    ## residue of xp wrt H
    zp,u = matResidual(H,zp,2*N)
    ## convert back into XP operator
    A = Zp2XP(zp,N)
    ## get new p and z components
    p,x0,z = XPcomponents(A)
    return makeXP(p,x,z),u

## Operator Residue of A wrt non-diagonal canonical generators SX
def XResidual(SX,A,N):
    if np.size(SX) == 0:
        return A,ZMat([])
    p,x,z = XPcomponents(A)
    ## H is X-component of SX
    H = XPx(SX)
    ## residue of z wrt H
    x1,u = matResidual(H,x,2)
    # # report(func_name(),'x1,u ',x1,u )
    B = GeneratorProduct(SX,u,N)
    # # report(func_name(),XP2Str(B,N))
    ## update A
    A = XPMul(A,XPInverse(B,N),N)
    return A,u

## Operator Residue of A wrt canonical generators S
def XPResidual(S,A,N): 
    # # report(func_name(),'A',XP2Str(A,N))
    # # report('S=')
    # # report(XP2Str(S,N))
    SX,SZ = splitDiag(S)  
    A,a = XResidual(SX,A,N)
    # # report(func_name(),'A',XP2Str(A,N))
    B,b = ZResidual(SZ,A,N)
    # # report(func_name(),'B',XP2Str(B,N))
    return B,np.hstack([a,b])   

## perform operations represented by U on S
def doOperations(S,U,N):
    if len(S) == 0:
        return S
    temp = []
    m,n = getmn(U)
    n = XPn(S)
    # for j in range(len(S),m):
    #     S.append(XPI(n))
    for j in range(len(U)):
        myrow = mat2list(U[j])
        op = GeneratorProduct(S,myrow,N)
        temp.append(op)
    return ZMat(temp,2*n+1)

## Prod(S[i]^u[i]) where S is a list of XP operators, u is a vector of integer
def GeneratorProduct(S,u,N):
    if len(S) == 0:
        return None
    n = XPn(S)
    u = np.mod(u,2*N)
    temp = XPI(n)
    for j in range(min(len(S),len(u))):
        uj = u[j]
        Sj = S[j]
        if uj >= 1:
            temp = XPMul(temp,XPPower(Sj,N,uj),N)
    return temp

def testGroup(G,N,C):
    ## check group exhaustively
    # SC,SG = XPSpan(C,N),XPSpan(G,N)
    # # report('SC')
    # # report(XP2Str(SC,N))
    # # report('SG')
    # # report(XP2Str(SG,N))
    # return ZMatEqual(SC,SG)
    ## check generators
    for g in G:
        # # report(func_name(),'g',g)
        R,u = XPResidual(C,g,N)
        if not isZero(R):
            print(func_name(),'g=',XP2Str(g,N),'R=', XP2Str(R,N))
            return False
    return True

## Canonical generators for set of XP operators G of precision N
def CanonicalGenerators(G,N,C=False):
    G = ZMat2D(G)
    if C is not False:
        print('Testing',func_name())
        return testGroup(G,N,C)
    n = XPn(G)
    ## Simplify X component
    S = simplifyX(G,N)
    # print('simplifyX')
    # print(XP2Str(S,N))
    # report('SimplifyX test:',testGroup(G,N,S))
    ## Split into diag and non-diag operators
    SX,SZ = splitDiag(S)
    ## Add squares and commutators of SX
    toDo = [SZ]
    # # report('Adding Squares and Commutators of SX')
    for A in SX:
        # # report('A',XP2Str(A,N))
        Sq = XPSquare(A,N)
        # # report('A^2')
        # # report(XP2Str(Sq,N))
        toDo.append(Sq)
        Comm = XPCommutator(A,SX,N)
        # # report('Comm')
        # # report(XP2Str(Comm,N))
        toDo.append(Comm)
    SZ = np.vstack(toDo)
    # # report('SZ')
    # # report(XP2Str(SZ,N))
    ## Simplify Z component
    SZ = simplifyZ(SZ,N)
    # report('SimplifyZ test SX squares & commutators:',testGroup(G,N,np.vstack([SX,SZ])))
    # # report('SZ')
    # # report(XP2Str(SZ,N))
    ## Add commutators between SX and SZ
    ## need to repeat t times
    t = max(0,logCeil(N-1,2))
    toDo = [SZ]
    for i in range(t-1):
        ## Commutators Level i+1
        for A in SX:
            ## commutators between X operators and Z operators
            toDo.append(XPCommutator(A,SZ,N))
        SZ = np.vstack(toDo)
        ## Simplify Z component
        SZ = simplifyZ(SZ,N)
        # report(f'SimplifyZ test Commutator level {i}:',testGroup(G,N,np.vstack([SX,SZ])))
        # # report('SZ')
        # # report(XP2Str(SZ,N))
    ## Simplify Z component of SX
    # # report('SX')
    # # report(XP2Str(SX,N))
    SX = simplifyXZ(SX,SZ,N)
    # report('SimplifyXZ test:',testGroup(G,N,np.vstack([SX,SZ])))
    # # report('SX')
    # # report(XP2Str(SX,N))
    return np.vstack([SX,SZ])

## check whether list of operators in canonical form S is admissible
## ie has any members with fundamental phase not equal to zero
def Admissible(S,N):
    f,d = XPFundamentalPhase(S,N)
    # # report(func_name(),'S')
    # # report(XP2Str(S,N))
    # # report('f',f)
    return np.all(f==0)


## Coset (Eq + u @ LXx) mod 2 where wt(u) <= w
## Also returns Qindex and Lindex 
def coset(Eq,LXx,w=None):
    k,n = np.shape(LXx)
    Et, Lindex, Qindex = [],[],[]
    w = k if w is None else min(k,w)
    for u in BinPowerset(k,w):
        for i in range(len(Eq)):
            Qindex.append(i)
            Lindex.append(u)
            Et.append(np.mod(Eq[i] + u @ LXx,2))
    return ZMat(Et,n),ZMat(Qindex,1),ZMat(Lindex,k)

## T is the set of binary vectors x such that Em + x = Em
# def getTOld(Em):
#     m,n = np.shape(Em)
#     if m == 0:
#         return ZMat([],n)
#     m0 = Em[0]
#     Em = ZMat(Em,n)
#     EmSet = {tuple(m) for m in Em}
#     Em0 = [np.mod(m - m0,2) for m in Em]
#     T = []
#     for x in Em0:
#         # Emx = np.mod(Em + x,2)
#         # if np.all([tuple(m) in EmSet for m in Emx]):
#         #     T.append(x)
#         if validT(Em,EmSet,x):
#             T.append(x)
#     return ZMat(T,n)

# def validTOld(Em,EmSet,x):
#     for e in Em:
#         if tuple(np.mod(e + x,2)) not in EmSet:
#             return False
#     return True

## return Eq, LXx such that Em = Eq + <LXx>
def cosetDecomposition(Em):
    m,n = np.shape(Em)
    LXx = []
    ## LXx is empty if m is not a multiple of 2
    if m > 0 and m % 2 == 0:
        EqSet = {tuple(m) for m in Em}
        Em0 = [np.mod(m - Em[0],2) for m in Em]
        while len(Em0)> 0:
            x = Em0.pop()
            if not isZero(x) and validT(EqSet,x):
                ## found an element of LXx
                LXx.append(x)
                l = leadingIndex(x)
                ## eliminate elements from EqSet and Em0 where e[l] == 1
                Em0 = [e for e in Em0 if e[l]==0]
                EqSet = {e for e in EqSet if e[l]==0}
    ## convert LXx from list to ZMat
    LXx = ZMat(LXx,n)
    ## No LXx found - return empty list and original Em
    if len(LXx) == 0:
        return Em,LXx
    ## Convert LXx to RREF
    nsp = NSpace(LXx,2)
    LXx = nsp.H
    ## Convert EqSet to ZMat
    Eq = ZMat(sorted(EqSet))
    return Eq,LXx

# def getT(Em):
#     m,n = np.shape(Em)
#     if m == 0 or m % 2 > 0:
#         return ZMat([],n),Em
#     m0 = Em[0]
#     Em = ZMat(Em,n)
#     EmSet = {tuple(m) for m in Em}
#     Em0 = [np.mod(m - m0,2) for m in Em]
#     T = []
#     # print(func_name(),'len(Em0)',len(Em0),'len(EmSet)',len(EmSet))
#     while len(Em0)> 0:
#         x = Em0.pop(0)
#         # Emx = np.mod(Em + x,2)
#         # if np.all([tuple(m) in EmSet for m in Emx]):
#         #     T.append(x)
#         if not isZero(x) and validT(EmSet,x):
#             T.append(x)
#             l = leadingIndex(x)
#             Em0 = [e for e in Em0 if e[l]==0]
#             EmSet = {e for e in EmSet if e[l]==0}
#             # print(func_name(),'found T',x)
#             # print(func_name(),'len(Em0)',len(Em0),'len(EmSet)',len(EmSet))
#     T = ZMat(T,n)
#     if len(T) == 0:
#         return T,Em
#     nsp = NSpace(T,2)
#     T = nsp.H
#     return T,sorted(EmSet)

def validT(EmSet,x):
    for e in EmSet:
        if tuple(np.mod(ZMat(e) + x,2)) not in EmSet:
            return False
    return True

# def cosetDecompositionOldNew(Em):
#     Em = ZMat(Em)
#     m,n = np.shape(Em)
#     ## get valid transitions
#     LXx,Eq = getT(Em)
#     ## No LXX - return trivial vals
#     if len(LXx) == 0:
#         return Eq,LXx,ZMat(list(range(m))),ZMat([[0]*m])
#     # print('LXx')
#     # print(ZmatPrint(LXx))
#     # print('Eq')
#     # print(Eq)
#     LXix = ZMat([leadingIndex(a) for a in LXx])
#     # print('LXx Sorted')
#     # print(ZmatPrint(LXx))
#     LIndex = np.transpose([Em[:,l] for l in LXix])
#     Res = np.mod(Em + LIndex @ LXx,2)
#     EqIx = {Eq[i]:i for i in range(len(Eq))}
#     QIndex = ZMat([EqIx[tuple(r)] for r in Res])
#     Eq = ZMat(Eq,n)
#     # print('Eq')
#     # print(ZmatPrint(Eq))    
#     # print('LXx')
#     # print(ZmatPrint(LXx))
#     # print('QIndex')
#     # print(QIndex)
#     # print('LIndex')
#     # print(ZmatPrint(LIndex))    
#     return Eq,LXx,QIndex,LIndex

# ## Decomposition Em = Eq + <LXx>
# ## also returns QIndex, LIndex
# def cosetDecompositionOld(Em):
#     Em = ZMat(Em)
#     m,n = np.shape(Em)
#     ## get valid transitions
#     LXx = getT(Em)
#     # report('T')
#     # report(ZmatPrint(LXx,2),"\n")
    
#     ## get RREF of T
#     if len(LXx) > 0:
#         Eq,LIndex,QIndex = [],[],[]
#         Xnsp = NSpace(LXx,2)
#         # LXx = RemoveZeroRows(Xnsp.H)
#         LXx = Xnsp.H
#         if len(LXx) == 0:
#             LXx = ZMatAddZeroRow(LXx)
#         Eq = set()
#         qCount = 0
#         for e in Em:
#             q,u = matResidual(LXx,e,2)
#             q = tuple(q)
#             Eq.add(q)
#             QIndex.append(q)
#             LIndex.append(u)
#     else:
#         QIndex = [tuple(e) for e in Em]
#         Eq,LIndex,QIndex = QIndex,[[0]]*m,QIndex
#     Eq = sorted(Eq)
#     EqDict = {Eq[i]:i for i in range(len(Eq))}
#     QIndex = [EqDict[e] for e in QIndex]
#     Eq,LXx,LIndex,QIndex = ZMat(Eq,n),ZMat(LXx,n),ZMat(LIndex,n),ZMat(QIndex,n)
#     # report('LXx is RREF(T)')
#     # report(ZmatPrint(LXx,2),"\n")
#     return Eq,LXx,QIndex,LIndex  

## orbit representatives Em
def getEm(S,N,check=False):
    n = XPn(S)
    if not Admissible(S,N):
        print('Generators are not admissible')
        return ZMat([],n)
    SX,SZ = splitDiag(S)

    #### Calculate x: Set representing leading indices of X-component
    li = leadingIndices(XPx(SX))
    x = ZMat([2]*(n+1))
    x[li] = 0
    # x[-1] = 1
    # report('x',x,"\n")

    ## array of Z and phase components
    Szp = XP2Zp(SZ,N,double=False)
    # report('Szp')
    # report(ZmatPrint(Szp,N),"\n")

    ##### Testing
    if check is not False:
        # # report('Checking Em')
        # # report('Em',check)
        E = binSolveNaive(Szp,N,1,x)
        # # report('solveNaive',E)
        return spaceSig(E) == spaceSig(check)

    # make NSpace modulo N from Szp
    nsp = NSpace(Szp,N)

    # make the kernel of A into a Howell basis
    nsp.simplifyKer()
    K = nsp.K
    # report('K')
    # report(ZmatPrint(K,N),"\n")
    
    ###### Calculate the solution graph D by calling espaceSolve
    # D is the graph
    # (n,b) is the starting node for the solution
    D,(n,b) = espaceSolve(K,N,b=None,x=x)

    ###### convert graph D to a list L
    # L is a list of vectors c modulo N of length m
    # representing linear combinations of the rows of K
    A = graph2List(D,(n,b),rev=True)
    A = ZMat(A)
    # report('A')
    # report(ZmatPrint(A,N),"\n")

    ###### Convert L to list of binary vectors B - these are the solutions
    # Em = ZMat([np.mod(a @ K, N) for a in A])
    Em = ZMat(np.mod(A @ K, N)) 
    
    ## Include only elements with 1 in -1 position
    ix = [i for i in range(len(Em)) if Em[i][-1]==1]
    Em = Em[ix]
    ## remove last column
    Em = Em[:,:-1]
    # report('Em',Em)
    return Em

## Orbit operator - SIndex weight less than t
def OrbitOperator(SX,N,t=None):
    n = XPn(SX)
    SIndex, OSx = ZMat([[]]),ZMat([XPI(n)])
    k = len(SX)
    t = k+1 if t is None else min(t,k+1) 
    # # report(func_name(),'t',t)       
    for i in range(k):
        ix = [i for i in range(len(SIndex)) if weight(SIndex[i]) < t-1]
        # # report(func_name(),'SIndex')
        # # report(ZmatPrint(Sindex,2))
        # # report('ix',ix)
        # Sindex = np.vstack([np.hstack([Sindex,0]), np.hstack([Sindex[ix],1])])
        col0 = np.zeros((len(SIndex),1),dtype=int)
        col1 = np.ones((len(ix),1),dtype=int)
        SIndex = np.vstack([np.hstack([SIndex,col0]), np.hstack([SIndex[ix],col1])])
        OSx = np.vstack([OSx,XPMul(OSx[ix],SX[i],N)])
    # # report('OSx')
    # # report(XP2Str(OSx,N),"\n")
    if np.size(SIndex) ==0:
        SIndex = ZMat([[0]])
    return OSx,SIndex

## codewords orbit distance less than t from Em
## can also be used for Eq/GX
def getCodewords(EmState,SX,N,t=None):
    OSx,SIndex = OrbitOperator(SX,N,t)
    # # report(func_name(),'OSx')
    # # report(XP2Str(OSx,N))
    return ZMat([XPMul(OSx,m,N) for m in EmState]),SIndex

def checkCodewords(codeWords,G,N):
    G = ZMat2D(G)
    valid = True
    for b in codeWords:
        for g in G:
            s = XPMul(g,b,N)
            if not StateEqual(s,b):
                # report('Codeword')
                # report(State2Str(b,N))
                # report('Generator',XP2Str(g,N))
                # report('XPMul(g,b,N)')
                # report(State2Str(s,N))
                valid = False
    return valid

## Return NSpace to calculate Logical Identities/Operators
## Codewords can be partial (eg orbit distance t from Em for Logical Operators)
def getNsp(CW,N):
    # # report(func_name(),ZMat2tuple(CW))
    # print(func_name(),ZMat2tuple(CW))
    m = len(CW)
    EL = []
    for i in range(m):
        x = XPx(CW[i])
        ## Logical Index
        ix = [set2Bin(m,[i])]*len(x)
        EL.append(np.hstack([x,ix]))
    EL = np.vstack(EL)
    # report('EL')
    # report(ZmatPrint(EL,2),"\n")
    nsp = NSpace(EL,N)
    nsp.simplifyKer()
    # report('KL')
    # report(ZmatPrint(nsp.K,N),"\n")
    return nsp

## Calculate Logical Identity generators M in canonical form
## Assuming we have canonical generators SX
def getLI(SX,nsp,N):        
    ## diagonal operators MZ correspond to Ker
    MZ = Zp2XP(nsp.K,N,double=False)
    ## take residue of Z components of SX
    MX = simplifyXZ(SX,MZ,N)
    return np.vstack([MX,MZ]) 

## Calculate Logical Operators generators L in canonical form

def getLZ(MZz,nsp,N,n):
    z,F = nsp.K[:,:n],nsp.K[:,n:]
    # report(func_name(), nsp.K)
    ## remove non-trivial diagonal operators
    LZz = []
    for zi in z:
        zi,u = matResidual(MZz,zi,N)
        if not isZero(zi):
            LZz.append(zi)
    nsp = NSpace(LZz,N)
    # nsp.simplifyH()
    return makeXP(0,0,ZMat(nsp.H,n))

def CW2LI(CW,N):
    # print(func_name(),CW)
    E = XPx(CW[0]) 
    T = np.mod(E + E[0],2)
    nsp = NSpace(T,2)
    # nsp.simplifyH()
    SXx = nsp.H
    # print('SXx',ZmatPrint(SXx))
    n = XPn(CW[0])
    CW1 = ZMat([np.vstack(CW)]) 
    nsp = getNsp(CW1,N)
    SX = CW2LX(CW,SXx,nsp,N)
    M = getLI(SX,nsp,N)
    # print(func_name(),XP2Str(M,N))
    return M

## Calculate non-diagonal logical operators from Codewords
def CW2LX(CW,LXx,nsp,N):
    n = XPn(CW[0])
    LX = []
    ## make dictionary from codewords - phase and codeword
    CWphases = CW2Dict(CW)
    # report(func_name())
    # for e,p in CWphases.items():
    #     report(e,p)
    for x in LXx:
        A = getLX(x,CW,CWphases,nsp,N)
        if A is not False:
            LX.append(A)
    return ZMat(LX,2*n+1)

def getLX(x,CW,CWphases,nsp,N):
    # # report(func_name())
    # report('\nFinding valid Z component for x =',x)
    # report('nsp.H')
    # report(ZmatPrint(nsp.H,N))
    n = XPn(CW[0])
    ## change in phase applied by XP_N(0|x|0)
    Deltap = []
    ## adjustment factor - either 0 or 1
    a = []
    
    for i in range(len(CW)):
        p0,x0,z0 = XPcomponents(CW[i])
        # # report('x0',x0)
        x1 = np.mod(x0+x,2)
        p1 = ZMat([CWphases[tuple(e)] for e in x1])
        # # report("p'")
        # # report(p1)
        dp = np.mod(p1 - p0,2*N)
        # report("p'' is the change in phase when applying the operator ")
        # report(dp)
        # # report('dp',dp)
        ## adjust precision of phase to N
        if N % 2 ==0:
            ## change in phase modulo 2 should be the same for all basis elts in codeword
            dpmod2 = set(np.mod(dp,2))
            if len(dpmod2) > 1:
                report(func_name(),'change in phase modulo 2 not constant for codeword')
                return False
            ai = dpmod2.pop()
            ## we adjust by subtracting ai and divide by 2
            dp = (dp - ai)//2
        else:
            ## use ring division - 2 is a unit in this case
            ai=0
            dp = vDiv(dp,2,N)
        a.append(ai)
        Deltap.append(dp)
    Deltap = np.hstack(Deltap)
    A = makeXP(0,x,0)
    report("p''' represents the change in phase to each basis element in the codewords when applying the operator ",XP2Str(A,N))
    report(Deltap)

    ## try to find a valid z component
    k,o = nsp.makeOffset(Deltap)
    # report('makeOffset',k,o)
    if not(isZero(o)):
        ## cannot find a solution
        report(func_name(),'makeOffset failed')
        return False
    else:
        ## get z component and phase vector
        report("b = (z|q) represents the Z component and phase vector of an operator which applies the change in phase p''':")
        report(k)
        z,f = k[:n],k[n:]
        ## adjust the overall phase of the operator - but only if size of f is 1:
        if len(f) > 1:
            p = 0
        else:
            ## we know adjustment a is constant and f has one element
            ## adjust to modulo 2N
            p = np.mod(a[0] + 2*f[0],2*N)
        A = makeXP(p,x,z)
        # report('A @ CW')
        # for c in CW:
            # report(State2Str(XPMul(A,c,N),N))
        return A


def ActionSolve(la,LD,FD,N):
    r,u = matResidual(FD,la,2*N)
    if isZero(r):
        Zp = XP2Zp(LD,N)
        A = matMul(u,Zp,2*N)
        return Zp2XP(A,N)
    return None

def SquareInMZ(x,MZz,N):
    ## <Sxp>: space where x is set
    Sxp = np.diag(x)
    ## <Sxn>: space where x is not set
    Sxn = np.diag(1-x)
    ## Here we are looking at the condition that A^2 in <MZ>
    ## Let A = XP_N(0|x|z)
    ## Let z_2 be the Z component of A^2. 
    ## If x[i] = 0, z_2[i] = 2z[i]. If x[i] = 1, z_2[i] = 0.
    ## z_2 is a multiple of 2 and is zero whenever x[i] = 0, so z_2 has to be in the intersection of <MZz> and 2<Sxn>
    ## Sp2: u in <Sp0> where u in <MZzp> and u[i]=0 when x[i]=1
    Sp2 = nsIntersection([MZz,np.mod(2*Sxn,N)],N)
    ## Sxp: Where x[i] = 1, u[i] can be anything as z_2[i] is always 0
    SpList = [Sp2//2, Sxp]
    ## N/2*Sxn: where N is even, Adding N/2 to u[i] when x[i]=0  does not affect whether z_2 in <MZz> as z_2[i] = 2z[i]
    if N % 2 == 0:
        SpList.append(N//2 * Sxn)
    return nsUnion(SpList,N)

## ensure that A^2 in <MZz>
def X2Solve(x,b,LZz,MZz,N,returnspan=False):
    Spa = SquareInMZ(x,MZz,N)
    ## b0 is all zero
    b0 = ZMatZeros(len(x))
    ## Possible values of u are from the coset b + <MZzp>+ <LZzp> ie b plus any phase/z component representing a diagonal logical operator
    ## But the v has to be in <Sp0> so we take the intersection
    SpM = np.vstack([MZz,LZz])
    return affineIntersection(SpM,b,Spa,b0,N) if returnspan else affineIntercept(SpM,b,Spa,b0,N) 

def minDistance(G):
    D = [XPdistance(op) for op in G]
    return min(D)

## make codewords less than orbit distance t from EmState
def getCWP(EmState,SX,N,P=None):
    if P is None:
        P = N
    t = logCeil(P-1,2) 
    t = t+1 if 2 ** t == P else None
    # report('t',t)
    CWL, SIndex = getCodewords(EmState,SX,N,t)
    return [XPSetN(c,N,P) for c in CWL]

############

def isLO(L,LI,N):
    for A in LI:
        C = XPCommutator(A,L,N)
        # # report(XP2Str(C,N))
        R,u = XPResidual(LI,C,N)
        # # report(XP2Str(R,N)) 
        if not XPisI(R):
            # report(func_name(),XP2Str(L,N),XP2Str(A,N),XP2Str(C,N),XP2Str(R,N))
            return False
    return True

## main class for XP codes
class Code:

    ## set defaults for new code
    ## G is a list of XP operators
    ## N is the precision 
    def __init__(self,G,N):
        self.N = N
        self.n = XPn(G)
        self.G = ZMat2D(G) 
        getVal(self,'S')
        getVal(self,'Em')
        getVal(self,'Eq')

    ## S is the canonical generators
    def getS(self):
        S = CanonicalGenerators(self.G,self.N)
        SX,SZ = splitDiag(S)
        setVals(self,['SX','SZ','SXx'],[SX,SZ,XPx(SX)])
        return S

    def getEm(self):
        Em = getEm(getVal(self,'S'),self.N)
        # # report(func_name(),'Em')
        # # report(Em)
        # p, z = ZMatZeros(len(Em)), ZMatZeros(np.shape(Em))
        # EmState = XPmergeComponents([p,Em,z])
        EmState = vec2state(Em)
        # # report(func_name(),State2Str(EmState,self.N))
        setVal(self,'EmState',EmState)
        return Em

    ## core Eq
    def getEq(self):
        Em = getVal(self,'Em')
        Eq,LXx = cosetDecomposition(Em)
        # p, z = ZMatZeros(len(Eq)), ZMatZeros(np.shape(Eq))
        EqState = vec2state(Eq)
        ## set values for 'EqState','LXx'
        setVals(self,['EqState','LXx'],[EqState,LXx])
        return Eq

    # def getEqOld(self):
    #     Em,EmState = getVals(self,['Em','EmState'])
    #     Eq,LXx,QIndex,LIndex = cosetDecomposition(Em)
    #     # # report(func_name(),'LXx',LXx)
    #     ## sort order for Em, QIndex, LIndex
    #     EmOrder = [(weight(LIndex[i]),) + tuple(LIndex[i]) + (QIndex[i],) for i in range(len(LIndex))]
    #     ix = argsort(EmOrder)
    #     p, z = ZMatZeros(len(Eq)), ZMatZeros(np.shape(Eq))
    #     EqState = XPmergeComponents([p,Eq,z])
    #     ## set values for 'EqState','Em','EmState','LXx','QIndex','LIndex'
    #     setVals(self,['EqState','Em','EmState','LXx','QIndex','LIndex'],[EqState,Em[ix],EmState[ix],LXx,QIndex[ix],LIndex[ix]])
    #     return Eq
        
    def getCodewords(self,check=False):
        S,EmState = getVals(self,['S','EmState'])
        SX,SZ = splitDiag(S)
        C,SIndex = getCodewords(EmState,SX,self.N)
        setVal(self,'SIndex',SIndex)
        return C

    def displayE(self):
        # Codewords, QIndex,LIndex,SIndex = getVals(self,['Codewords', 'QIndex','LIndex','SIndex'])
        # E = [ZMat2str(XPx(c)) for c in Codewords]
        Eq,SXx,LXx = getVals(self,['Eq','SXx','LXx'])
        Em,QIndex,LIndex = coset(Eq,LXx)
        LIndex = ZMat2str(LIndex)
        Ei,Qi,SIndex = coset([Em[0]],SXx)
        SIndex = ZMat2str(SIndex)
        QIndex = np.char.mod('%d', QIndex)
        labels = []
        body = []
        labels.append(["","Stabilizer Index"])
        body.append(SIndex)
        labels.append(['Logical Index','Core Index'])
        body.append([""]*len(SIndex))
        for i in range(len(QIndex)):
            labels.append([LIndex[i],QIndex[i]])
            Ei,Qi,SIndex = coset([Em[i]],SXx)
            body.append(ZMat2str(Ei))
        data = np.hstack([labels,body])
        return ZmatTable(data,[2],[2])

    ## codewords orbit distance t = log2(P) from Eq
    ## for calculating Logical Identities and Regular Generators
    def getCWI(self,P=None):
        if P is None:
            P = self.N
        EqState, LXx, SX = getVals(self,['EqState', 'LXx', 'SX'])
        if len(EqState) ==0:
            return ZMatZeros(np.shape(EqState))
        ## we don't know phase + Z components for LX
        LX = makeXP(0,LXx,0)
        CWI = getCWP(EqState,np.vstack([SX,LX]),self.N,P)
        ## merge into one single codeword
        return ZMat([np.vstack(CWI)])

    ## codewords orbit distance t = log2(P) from Em
    ## for calculating Logical Operators
    def getCWL(self,P = None):
        Em,EmState,SX = getVals(self,['Em','EmState','SX'])
        return getCWP(EmState,SX,self.N,P)

    def getLI(self,P=None):
        if P is None:
            P = self.N
        ## not yet coded for lower precisions
        if P < self.N:
            return False
        SX = getVal(self,'SX')
        if self.N < P:
            SX1 = XPSetN(SX,self.N,P)
            if SX1 is False:
                return None
            SX = SX1
        CWI = self.getCWI(P)

        if len(CWI) ==0:
            return ZMat([],2*self.n +1)
        nsp = getNsp(CWI,P)
        # setVal(self,'nspLI',nsp)
        return getLI(SX,nsp,P)       

    def ZSymmetries(self):
        LI = getVal(self,'LI')
        MX,MZ = splitDiag(LI)
        MXz = XP2Zp(LI,self.N)
        # MXz = np.hstack([MXz,[[1]]*len(MXz)])
        nsp = NSpace(MXz,2*self.N)
        Kt = nsp.getVal('Kt')
        MXx = XPx(LI)
        Symm = matMul(Kt,MXx,2)
        # return RemoveZeroRows(Symm)
        nsp = NSpace(Symm,2)
        return RemoveZeroRows(nsp.H) 

    def getLO(self,P=None):
        # # report(func_name())
        P = self.N if P is None else P
        Em,Eq,LXx = getVals(self,['Em','Eq','LXx'])
        if len(Em) ==0:
            return ZMat([],2*self.n +1)
        M = self.getLI(P)
        CWL = self.getCWL(P)
        # setVerbose(True)
        # report('CWL',func_name())
        # for c in CWL:
        #     report(State2Str(c,P))
        nsp = getNsp(CWL,P)
        # report('LXx',LXx)
        LX = CW2LX(CWL,LXx,nsp,P)
        # report('LX',np.shape(LX))
        MX,MZ = splitDiag(M)
        MZz = XPz(MZ)
        LZ = getLZ(MZz,nsp,P,self.n)
        # setVal(self,'nspLO',nsp)
        # setVerbose(False)
        if P == self.N:
            setVal(self,'EmState',None)
        return np.vstack([LX,LZ])

    def Fvector(self,A):
        ## need to get LO to ensure that EmState is ordered by orbit distance
        LO, EmState = getVals(self,['LO','EmState'])
        return Fvector(A,EmState,self.N)

    def analyseLO(self,A):
        N = self.N
        temp = ['Analysing: ' + XP2Str(A,self.N)] 
        ## check if A is a logical operator
        M = getVal(self,'LI')
        LO, EmState = getVals(self,['LO','EmState'])
        if not isLO(A,M,N):
            temp.append("Not a Logical Operator")
        else:
            temp.append('Is a Logical Operator')
            ## get F vector and reshape intro rows with same LIndex
            EmState,QIndex,LIndex = getVals(self,['EmState','QIndex','LIndex'])
            LIndex = ZMat2str(LIndex)
            QIndex = np.char.mod('%6d', QIndex)
            LIndex, Lix = np.unique(LIndex, return_index=True)
            QIndex, Qix = np.unique(QIndex, return_index=True)

            f = Fvector(A,EmState,N)
            temp.append("F vector: " + str(f))
            f = np.reshape(f,(len(LIndex),len(QIndex)))
            f = np.char.mod('%d', f)

            ## create table
            labels = []
            body = []
            labels.append("")
            body.append(['QIndex'] + [''] * (len(QIndex)-1))
            labels.append('LIndex')
            body.append(QIndex)
            for i in range(len(LIndex)):
                labels.append(LIndex[i])
                body.append(f[i])
            labels = np.transpose([labels])
            data = np.hstack([labels,body])
            temp.append('Regular/Core Analysis:')
            temp.append(ZmatTable(data,[2],[1])) 
        return "\n".join(temp)

    def getwI(self):
        wI = ZMatZeros(2*self.n+1)
        wI[-1] = 1
        return wI

    def getLD(self):
        N = self.N
        L,EmState,wI = getVals(self,['LO','EmState','wI'])
        # # report(func_name(),'EmState',EmState,len(EmState))
        if len(EmState) == 0:
            setVal(self,'FD',[])
            return ZMat([],2*self.n + 1)
        LX,LZ = splitDiag(L)
        LZ = np.vstack([wI,LZ])
        FZ = [self.Fvector(A) for A in LZ]
        nsp = NSpace(FZ,2*N)
        FD = nsp.getVal('H')
        ix = [not isZero(A) for A in FD]
        ix = [i for i in range(len(FD)) if not isZero(FD[i])]
        FD = FD[ix]
        U = nsp.getVal('P')
        Zp = XP2Zp(LZ,N)
        Zp = matMul(U,Zp,2*N)
        LD = Zp2XP(Zp,N)
        LD = LD[ix]
        setVal(self,'FD',FD)
        return LD

    ## map regular code to CSS code with similar LO structure
    def getR(self):
        Eq = getVal(self,'Eq')
        ## check if regular
        if len(Eq) > 1:
            return False
        ## Calculate RX: regular non-diagional generators
        SXx = getVal(self,'SXx')
        RX = makeXP(0,SXx,0) 
        ## CWI: codewords at most orbit distance 1 from Eq       
        N=2
        CWI = self.getCWI(N)
        nsp = getNsp(CWI,N)
        return getLI(RX,nsp,N)

    def getdimension(self):
        Em = getVal(self,'Em')
        return len(Em)

    def getdistance(self):
        M = getVal(self,'LI')
        L = getVal(self,'LO')
        d = self.n
        N = self.N
        for A in XPSpan(L,N):
            print('A',XP2Str(A,N))
            R, u = XPResidual(M,A,N)
            if not isZero(R):
                dA = self.n
                CA = None
                for B in XPSpan(M,N):
                    C = XPMul(A,B,N)
                    d2 = XPdistance(C)
                    if d2 > 0 and d2 < dA:
                        dA = d2
                        CA = C
                R, u = XPResidual(M,CA,N)
                # print('R',XP2Str(R,N))
                # print('u',u)
                # print('CA',XP2Str(CA,N))
                # print('isLO',isLO(CA,M,N))
                if dA < d:
                    d = dA
        return d

    def getLogicalZ(self):
        LIndex,LD,FD = getVals(self,['LIndex','LD','FD'])
        LogicalZ = []
        if len(LIndex) == 0:
            return LogicalZ
        else:
            k = len(LIndex[0])
            for i in range(k):
                la = LIndex[:,i] * self.N
                A = ActionSolve(la,LD,FD,self.N)
                if A is not None:
                    LogicalZ.append(A)
        return ZMat(LogicalZ,2*self.n+1)

    def getLogicalX(self):
        LI,LO,wI,Eq = getVals(self,['LI','LO','wI','Eq'])
        if len(Eq) == 0:
            return ZMat([],2*self.n + 1)
        N = self.N
        MX,MZ = splitDiag(LI)
        LX,LZ = splitDiag(LO)
        LogicalX = []
        LZz,MZz = XPz(LZ),XPz(MZ)
        for A in LX:
            # report('\nFinding valid Z component for operator A =',XP2Str(A,N))
            p,x,b = XPcomponents(A)
            z = X2Solve(x,b,LZz,MZz,N)
            if z is not False:
                # report('Found valid Z component:',z)
                A = makeXP(0,x,z)
            else:
                print(func_name(),'could not find Z component such that A^2 in <MZ>: ',XP2Str(A,N))
            A2 = XPSquare(A,N)
            # report(XP2Str(A,N),"^2 =",XP2Str(A2,N))
            R,u = XPResidual(MZ,A2,N)
            # # report('XPResidual R =',XP2Str(R,N))
            p = np.mod(-XPp(R),2*N)//2
            # report('Adjusted phase p =',p)
            A = XPMul(A,p*wI,N)
            A2 = XPSquare(A,N)
            # report('Checking:',XP2Str(A,N),"^2 =",XP2Str(A2,N))
            LogicalX.append(A)
        ## convert from list to Zmat
        LogicalX = ZMat(LogicalX,2*self.n+1)
        ## update LO
        setVal(self,'LO',np.vstack([LogicalX,LZ]))
        setVal(self,'EmState',None)
        return LogicalX

    ## update EmState to take into account phases introduced by Logical X operators

    def getEmState(self):
        EqState,LO = getVals(self,['EqState','LO'])
        LX,LZ = splitDiag(LO)
        OSx,SIndex = OrbitOperator(LX,self.N)
        EmState = np.vstack([XPMul(A,EqState,self.N) for A in OSx])
        q = len(EqState)
        Qix = list(range(q))
        QIndex = np.hstack([Qix for A in OSx])
        LIndex = np.vstack([[Lix]*q for Lix in SIndex])
        setVals(self,['QIndex','LIndex'],[QIndex,LIndex])
        return EmState

    def getEmStateOld(self):
        EqState,LO = getVals(self,['EqState','LO'])
        LX,LZ = splitDiag(LO)
        CW, LIndex = getCodewords(EqState,LX,self.N)
        EmState = np.vstack([c for c in CW])
        QIndex = np.hstack([[i]*len(LIndex) for i in range(len(CW))])
        LIndex = np.vstack([LIndex for c in CW])
        setVals(self,['QIndex','LIndex'],[QIndex,LIndex])
        return EmState

## Z2 symmetries for a state
def StateSymmetries(myState):
    phaseSets = dict()
    for r in myState:
        p,x,z = XPcomponents(r)
        if p not in phaseSets:
            phaseSets[p] = []
        phaseSets[p].append(x)
    symmetries = []
    for p,Ep in phaseSets.items():
        Ep = ZMat(Ep)
        Eq,LXx = cosetDecomposition(Ep)
        symmetries.append(LXx)
    return nsIntersection(symmetries,2)

#################################        
##        Measurements         ##
################################# 


## measure abritrary XP operator A by applying projectors onto the code words
def MeasureCodewords(CW,A,N):
    # # report(func_name(),CW)
    n = XPn(A)
    nZero = ZMatZeros(n)
    A0 = np.sum([stateAmplitude(c,N) for c in CW])
    # for S in CW:
    #     print(S)
    # # report('Amplitude of pre-measurement codewords: ',A0)
    L = XPEigenvalues(A,N)
    ## outcome probabilities
    p1 = []
    ## projected codewords
    CW1 = []
    P = 2*N
    for l in L:
        B = makeXP(-l,nZero,nZero)
        ## update phase of operator A to ensure we are using the right projector
        C = XPMul(A,B,N)
        # # report('l,C',l,XP2Str(C,N))
        ## apply projector to codewords
        Scl = [XPProj(C,S,N) for S in CW]
        CW1.append(Scl)
        ## calculate outcome probability
        Al = sum([stateAmplitude(Sl,P,cl) for Sl,cl in Scl ])
        p1.append(Al/A0)
    return L, p1, CW1

## parity function for measuring diagonal Paulis
def Par(x,z):
    return matMul(z,np.transpose(x),2)[0]

def MeasureDiagPauli(Eq,SX,LX,z,N):
    # # report(func_name(),np.shape(SX),np.shape(LX))
    ## get X components of SX,LX
    SXx,LXx = XPx(SX),XPx(LX)
    ## split SX into parity 0/1 operators
    ix = Par(SXx,z)
    # # report('ix',ix)
    SX,SX1 = SX[ix==0],SX[ix==1]
    # # report('SX,SX1',SX,SX1)
    ## split LX into parity 0/1 operators
    ix = Par(LXx,z)
    LX,LX1 = LX[ix==0],LX[ix==1]
    ## find parity 1 operator B
    B = None
    if len(SX1) > 0:
        B = SX1[0]
        SX1 = np.delete(SX1,0,axis=0)
    if B is None and len(LX1) > 0:
        B = LX1[0]
        LX1 = np.delete(LX1,0,axis=0)
    ## update SX,LX,Eq if B is found
    if B is not None:
        
        ## Update Eq
        x = XPx(B)
        Eq = np.vstack([Eq,np.mod(Eq+x,2)])
        ## Update SX
        if len(SX1) > 0:
            SX1 = XPMul(B,SX1,N)
            SX = np.vstack([SX,SX1])
        ## Update LX
        if len(LX1) > 0:
            LX1 = XPMul(B,LX1,N)
            LX = np.vstack([LX,LX1])
        report('Found B =', XP2Str(B,N))
        report('\nUpdated Core: Eq =')
        report(ZmatPrint(Eq,2))
        report('\nUpdated Non-Diagonal Canonical Generators: SX =')
        report(XP2Str(SX,N))
        report('\nUpdated Logical X Operators: LX =')
        report(XP2Str(LX,N))
    else:
        report('B not found - no update to Eq, SX, LX')
    nEq = len(Eq)
    ## split Eq into parity 0/1 vectors
    ix = Par(Eq,z)
    Eq0,Eq1 = Eq[ix==0],Eq[ix==1]
    # # report('Eq+ =')
    # # report(ZmatPrint(Eq0,2))
    # # report('Eq- =')
    # # report(ZmatPrint(Eq1,2))    
    ## return updated core format for outcome +1 and -1
    return (Eq0,SX,LX,len(Eq0)/nEq),(Eq1,SX,LX,len(Eq1)/nEq)

## Measure a Logical Operator on the Code
## main issue updating LX - resort to getLX
## was hoping to have a more straightforward update method...
# def MeasureLO(A,Eq,SX,LX,LI,N):
#     ## check if we have a logical operator
#     if not isLO(A,LI,N):
#         return False
#     ## take residual wrt LI
#     A,u = XPResidual(LI,A,N)
#     n = XPn(np.vstack([LX,LI]))
#     todo = []
#     ## measure diagonal operator
#     if XPisDiag(A):
#         LXx = XPx(LX)
#         Em,QIndex,LIndex = coset(Eq,LXx)
#         EmState = XPmergeComponents([ZMatZeros(len(Em)),Em,ZMatZeros(np.shape(Em))])
#         ## Any codewords where phase applied is not 1 are removed
#         f = Fvector(A,EmState,N)
#         ix = f==0
#         Em1 = Em[ix]
#         ## Get the new Core and X components of LX
#         Eq1,LXx1,QIndex,LIndex = cosetDecomposition(Em1)
#         LX1 = []
#         for x in LXx1:
#             r,u = matResidual(LXx,x,2)
#             if isZero(r):
#                 LX1.append(GeneratorProduct(LX,u,N)) 
#             else:
#                 print(func_name(),"Non-zero residual for x=",x)
#                 L = XPmergeComponents([0,x,ZMatZeros(n)])
#                 todo.append(L)
#     else:
#         ## measure non-diag operator
#         ## First measure A^2
#         A2 = XPSquare(A,N)
#         Eq1,SX,LX = MeasureLO(A2,Eq,SX,LX,LI,N)
#         LX1 = []
#         l = leadingIndex(XPx(A))
#         for L in LX:
#             ## remove from LX if same leading index
#             if leadingIndex(XPx(L)) != l:
#                 L = getLX(x,CW,CWphases,nsp,N)
#                 LX1.append(L)
#         SX = np.vstack([SX,[A]])
#     LX1 = ZMat(LX1,2*n+1)
#     return Eq1,SX,LX1

## convert core format to stabilizer format
def core2stabs(Eq,SX,LX,N):
    t = logCeil(N)
    d = t if 1 << t == N else None
    GX = np.vstack([SX,LX])
    Et,QIndex,LIndex = coset(Eq,XPx(GX))
    nsp = NSpace(np.hstack([Et,np.ones((len(Et),1),dtype=int)]),N)
    nsp.simplifyKer()
    return getLI(SX,nsp,N)


#################################        
##   Simultaneous Eigenspaces  ##
#################################  

## hashable signature of eigenspace
def spaceSig(L):
    temp = [tuple(l) for l in L]
    return tuple(sorted(temp))

## text version of eigenspace
def spaceTxt(L):
    T = ["".join(map(str,x)) for x in L]
    return "\\".join(T)+ "\\"

## solve for Ae = p
# A is m x n matrix modulo N
# p is a length m string modulo N representing phases
# x is a list of indices 0 <= i < n where we require e[i] = 0
# output [e] are is a length n binary string
def binSolve(A,N,p=None,x=None,check = False):
    # no rows in A, return empty list
    if len(A) == 0:
        return []
    # default for p vector
    if p is None:
        p = [0] * len(A)
    # default for x vector
    if x is None:
        x = []
    x = set(x)
    # make NSpace modulo N from A
    nsp = NSpace(A,N)
    # make an offset b - solutions modulo N are in the format
    # x = b + k where k in Ker(A)
    b,o = nsp.makeOffset(p)

    # if o[c] > 0 for some c, then there is no solution
    if not isZero(o,N):
        return []
    # convert b to list format
    b = mat2list(b)
    # make the kernel of A into a Howell basis
    nsp.simplifyKer()
    K = nsp.K
    b,ix = matResidual(K,b,N)
    # check is for testing
    if check is not False:
        # report('Checking binSolve')
        # report('binSolve',check)
        E = binSolveNaive(A,N,p,x)
        # report('solveNaive',E)
        return spaceSig(E) == spaceSig(check)
    # call espaceSolve
    # D is the graph
    # (n,b) is the starting node for the solution
    D,(n,b) = espaceSolve(K,N,b=b,x=x)
    # convert graph D to a list L
    L = graph2List(D,(n,b),rev=True)
    L = ZMat(L)
    # # report('L',L)
    # L is a list of vectors c modulo N of length m
    # representing linear combinations of the rows of K
    # Convert these to binary vectors B
    if len(L):
        B = [np.mod(a @ K + b, N) for a in L]
    else:
        B = []
        if np.all([i < 2 for i in b]):
            B.append(b)
    return ZMat(B)

# ## Incremenet binary row
def binRowInc(val):
    carry = 1
    i = len(val) - 1
    while carry > 0 and i > -1:
        if val[i] == 1:
            val[i] = 0
        else:
            val[i] = 1
            carry = 0
        i = i -1
    return val

def binSpliceZeros(val,x):
    ## splice zeros into positions indicated by x
    temp = []
    ## i is the counter for position in val
    i = 0
    ## j is the counter for position in temp
    for j in range(len(val) + len(x)):
        ## if j in x, we need to have a zero in this position
        if j in x:
            temp.append(0)
        else:
            ## check if i is a valid counter for val
            if i < len(val):
                temp.append(val[i])
                i+=1
    return temp

# solve for Ax = p in binary strings
# positions indicated by x are zero
def binSolveNaive(A,N,p,x):
    temp = []
    m = len(A)
    if m == 0:
        ## nothing to check - return empty array
        return temp
    if p is None:
        ## phase to solve for p = 1 by default
        p = [0]* m
    ## ensure 0 <= p < N
    p = np.mod(p,N)
    ## make sure that all entries in x are valid
    x = [i for i in x if i < len(A[0])]
    ## all entries in x are zero, so fewer options to check
    n = len(A[0]) - len(x)
    ## initial value of e - 0
    e = [0] * n
    for k in range(1 << n):
        ## splice zeros into positions indicated by x
        ex = binSpliceZeros(e,x)
        ex = ZMat(ex)
        r = 0
        valid = True
        ## check phase for each row of A
        while r < len(A) and valid:
            ## multiply ex by A[r], modulo N
            if np.sum(ex * A[r]) % N != p[r]:
                valid = False
            r += 1
        if valid:
            temp.append(ex)
        ## next value of e
        e = binRowInc(e)
    return ZMat(temp)

## generic graph to list
def graph2List(D,ix=None,rev=False,s=tuple()):
    if ix is None:
        ix = max(D.keys())
    temp = []
    (n,p) = ix
    if ix in D:
        if len(D[ix]):
            for d,p1 in D[ix].items():
                s1 = s+(d,) if rev else (d,)+s
                n1 = n+1 if rev else n-1
                if p1 is not None:
                    # temp += graph2List(D,(n1,p1),rev,s1)
                    temp.extend(graph2List(D,(n1,p1),rev,s1))
                else:
                    temp.append(s1)
    return temp

## print generic graph
def printGraph(D):
    nodeCount = dict()
    # KList = sorted(D.keys(),reverse=True)
    KList = D.keys()
    for k in KList:
        L = len(D[k])
        # if L > 0:
            # # report(k,D[k])
        if L not in nodeCount:
            nodeCount[L] = 1
        else:
            nodeCount[L] += 1
    m = max(nodeCount.keys())+1
    nodeCount = [nodeCount[i] if i in nodeCount else 0 for i in range(m)]
    # report('nodeCount',nodeCount)
    # report('total Nodes',sum(nodeCount))

def leadingIndices(K):
    n = len(K)
    if n == 0:
        return []
    L = [len(K[0])] * (n)
    m = len(K[0])
    i = 0
    j = 0
    while i < m and j < n:
        if K[j][i] == 0:
            i += 1
        else:
            L[j] = i
            j+=1
            # i+=1
    return L

# zeroCols[r] = [c] where K[r][c] = 0 for all r
def zeroCols(K):
    m = len(K)
    if m ==0:
        # no rows, return empty list
        return []
    # length of first row of K
    n = len(K[0])
    # colSetRows[c] = [r] such that K[r][c] > 0
    colSetRows = [[r for r in range(m) if K[r][c] > 0] for c in range(n)]
    return [c for c in range(n) if len(colSetRows[c]) == 0]

# lowestCols[r] = [c] where K[r][c] > 0 and K[s][c] = 0 for all s > r
# If binarising, when we get to row r of K, b[c] must all be 0 or 1 
# as this is the last row where the b[c] can change
def lowestCols(K):
    m = len(K)
    if m ==0:
        # no rows, return empty list
        return []
    # length of first row of K
    n = len(K[0])
    # colSetRows[c] = [r] such that K[r][c] > 0
    colSetRows = [[r for r in range(m) if K[r][c] > 0] for c in range(n)]
    # temp is a vector of length m = len(K)
    temp = [[] for r in range(m)]
    for c in range(n):
        # check if there are any rows r where K[r][c] > 0
        if len(colSetRows[c]) > 0:
            # r is the largest such that K[r][c] > 0
            r = max(colSetRows[c])
            # append c to the list for row r
            temp[r].append(c)
    return temp

# Solve for e = b + cK for vector c such that:
# 0 <= c[i] < N, 0 <= i < len(K)
# e a binary vector, e[x] = 0
def espaceSolve(K,N,b=None,x=None):
    K = ZMat(K)
    m,n = np.shape(K)
    # # report('K')
    # # report(K)
    # set defaults for vector x
    if x is None:
        x = [None]*n    
    # x = set(x)
    # set defaults for vector b
    if b is None:
        b = [0]*n
    # starting node = ix
    # starting row of K=0
    # residual vector=b 
    ix = (0,tuple(b))
    # initialize graph
    D = dict()

    # get lowestCols of K
    LC = lowestCols(K)
    # report('LC',LC)
    # call recursive function espaceGraph
    temp = espaceGraph(K,N,x,ix,D,LC)
    # return the graph D and starting node ix
    return D,ix
		
## graph solution of eigenspace of operator list K
def espaceGraph(K,N,x,ix,D,LC):
    if ix in D:
        return D[ix]
    temp = dict()
    # r: row number of K
    # b0: residual vector we are seeking to binarise
    r,b0 = ix
    # L: lowestCols; Lr = lowestCols[r]
    Lr = LC[r]
    # l: index of leading nonzero entry of K[r]
    li = Lr[0]
    # p: corresponding entry in b0 - needs to be 0 or 1
    p = b0[li]
    # k: corresponding entry in K[r]
    k = K[r][li]
    # cList: possible values c such that p + k * c = 0/1 mod N
    aList = []
    
    if x[li] != 1:
        a = Div(-p,k,N)
        # in this case, we can make p + k * c = 0
        if a is not None:
            aList.append(a)
    if x[li] != 0:
        a = Div(1-p,k,N)
        # in this case, we can make p + k * c = 1
        if a is not None:
            aList.append(a)
    # if x[li] != 1 and p % k  == 0:
    #     # in this case, we can make p + k * c = 0
    #     a = ((N-p)//k) % N
    #     aList.append(a)
    # if x[li] != 0 and (p-1) % k == 0:
    #     # in this case, we can make p + k * c = 1
    #     # if l in x, then only 0 is allowed
    #     a = ((N+1-p)//k) % N
    #     aList.append(a)
    if len(aList):
        b0 = ZMat(b0)
        PSet = {}
        for a in aList:
            # b1 is b0 + c * K[r]
            b1 = np.mod(b0 + a * K[r],N)
            # b1[l] = 0
            valid = True 
            i = 1
            while valid and i < len(Lr):
                j = Lr[i]
                # valid = b1[j] < 1 if j in x else b1[j] < 2
                if x[j] == 2:
                    valid = b1[j] < 2
                else:
                    valid = b1[j] == x[j]
                # if j in x, then only 0 is allowed for b1[j]
                # otherwise, either 0 or 1 is allowed
                # b1[j] = 0
                i += 1
            if valid:
                # set b1 corresponding to Lr to zero - these are all 0 or 1
                b1[Lr] = 0
                PSet[a] = tuple(b1)
        if r == len(K) - 1:
            # in this case, we are at the last row of K
            for a,b1 in PSet.items():
                # base case - no recursion required
                temp[a] = None
        else:
            for a,b1 in PSet.items():
                # recursion - s = solutions for r+1, for vector b1
                s = espaceGraph(K,N,x,(r+1,b1),D,LC)
                if len(s):
                    # if there are valid solutions, create a link in the node
                    temp[a] = b1
    # update the solutions graph
    D[ix] = temp
    return temp 
